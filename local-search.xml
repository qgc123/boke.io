<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>dp刷题-爬楼梯</title>
    <link href="/2023/06/26/dp%E5%88%B7%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2023/06/26/dp%E5%88%B7%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原题链接：<a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯 - 力扣（LeetCode）</a></p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3.<span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>每次可以爬一级或者两级，因此最后一次要么是爬了1级，要么是爬了2级，所以问题可以转化为爬上（n-1）级楼梯和爬上（n-2）级楼梯分别有多少种方法，再求两者的和，即：<br>f（x）&#x3D;f（x-1）+f（x-2）；也就是斐波那契数列。</p><p>此题中，base case是：dp[0] &#x3D; 0,dp[1] &#x3D; 1;dp[2]&#x3D;2<br>状态转移方程是：dp[i] &#x3D; dp[i-1] + dp[i-2];</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>状态压缩</strong>，每次只记录必要的数据，即前两个数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录如下：</p><p><img src="/2023/06/26/dp%E5%88%B7%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20230626190019486.png" alt="image-20230626190019486"></p><p>可以看出内存还可以优化，突然想起来两数的替换好像可以不用开辟额外的内存空间，如果我要替换a和b代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a=a+b;<br>b=a-b;<br>a=a-b;<br></code></pre></td></tr></table></figure><p>在此基础上略微修改，我们需要的值是a+b最后在b上，b在a上，如此代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-comment">// 计算这一轮的新值</span><br>            a=a+b;<br>            <span class="hljs-comment">// 替换位置</span><br>            a=a+b;<br>            b=a-b;<br>            a=a-b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录如下：</p><p><img src="/2023/06/26/dp%E5%88%B7%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20230626191222403.png" alt="image-20230626191222403"></p><p>可以看出还可以继续优化（剩下的0.25%是什么魔鬼&gt;&lt;），仔细想想，for循环中的i好像可以优化掉，然后试了一下，内存反倒增加了</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(;n &gt;= <span class="hljs-number">3</span>;n--)&#123;<br>            a=a+b;<br>            a=a+b;<br>            b=a-b;<br>            a=a-b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录：</p><p><img src="/2023/06/26/dp%E5%88%B7%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20230626192729974.png" alt="image-20230626192729974"></p><p>内存这个东西好像要靠运气，我多交了几次发现内存有波动。</p><p><img src="/2023/06/26/dp%E5%88%B7%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20230626193229910.png" alt="image-20230626193229910"></p><p>既然这样这题就到这里吧！！！&gt;.&lt;</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习相关概念及其相关算法概述</title>
    <link href="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一-相关概念"><a href="#一-相关概念" class="headerlink" title="一.相关概念"></a>一.相关概念</h1><h2 id="1-有监督和无监督学习"><a href="#1-有监督和无监督学习" class="headerlink" title="1.有监督和无监督学习"></a>1.<strong>有监督和无监督学习</strong></h2><ul><li>监督学习（有监督学习）是对有标签数据训练数据集进行建模，再用模型对新的数据样本进行分类或者回归分析的机器学习算法。</li><li>无监督学习（非监督式学习）是对没有标签的数据集进行建模，再用模型对新的数据样本进行分类或者回归分析的机器学习算法。</li></ul><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626105827119.png" alt="有监督学习"></p><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626105731364.png" alt="无监督学习"></p><h2 id="2-分类和回归"><a href="#2-分类和回归" class="headerlink" title="2.分类和回归"></a>2.<strong>分类和回归</strong></h2><ul><li>分类是预测样本属于哪个类别。</li><li>回归是预测样本目标字段的数值。</li></ul><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626105647391.png" alt="分类和回归"></p><h2 id="3-数据集和特征"><a href="#3-数据集和特征" class="headerlink" title="3.数据集和特征"></a>3.<strong>数据集和特征</strong></h2><ul><li>数据集是预测系统的原材料，用于训练机器学习模型的历史数据。</li><li>特征是描述数据集中每个样本的属性，有时候也被称为“字段。</li></ul><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626105610176.png" alt="猫狗识别案例"></p><h2 id="4-特征工程"><a href="#4-特征工程" class="headerlink" title="4.特征工程"></a>4.<strong>特征工程</strong></h2><ul><li>特征工程是创建预测模型之前的过程，在这个过程中我们将对数据的特征进行分析、清理和结构化。</li></ul><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626105924743.png" alt="特征工程"></p><h2 id="5-过拟合与欠拟合"><a href="#5-过拟合与欠拟合" class="headerlink" title="5.过拟合与欠拟合"></a>5.<strong>过拟合与欠拟合</strong></h2><ul><li><p>欠拟合</p><ul><li>当机器学习算法无法捕获数据的潜在趋势时，可以看成当模型或算法无法很好地拟合数</li></ul><p> 据时，会发生欠拟合。</p></li><li><p>过拟合</p><ul><li>当数据中存在大量噪声并被机器学习算法捕获时，可以看成当模型或算法对训练数据拟</li></ul><p> 合得“太好”时，会发生过拟合。</p></li></ul><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626110058541.png" alt="过拟合与欠拟合"></p><h1 id="二-线性模型"><a href="#二-线性模型" class="headerlink" title="二.线性模型"></a>二.线性模型</h1><ul><li><p>概念</p><ul><li>线性模型并不是指某一种算法，而是一类<strong>算法的统称</strong>。线性模型虽然已经存在了很长时间，但如今仍然是<strong>使用最多的算法之一</strong>。</li></ul></li><li><p>优缺点</p><ul><li>该类算法性能表现优越，即便是在超大型数据集中，训练速度也非常快</li><li>原理易于理解</li></ul></li><li><p><strong>线性模型的基本公式</strong></p><ul><li>线性模型包括线性回归、套索回归、岭回归、逻辑回归和线性支持向量机等。</li><li>线性模型的基本公式如下：</li></ul></li></ul><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626111003623.png" alt="线性模型公式"></p><ul><li>eg：<ul><li>假设某个数据集中的样本都只有1个特征，则线性模型可以表示为：ŷ &#x3D; w·x+b</li><li>如：最后训练出来的特征权重 w&#x3D;-2，偏差 b&#x3D; 3，则模型为： <strong>ŷ</strong> <strong>&#x3D;</strong> <strong>-2x+3</strong></li></ul></li></ul><h1 id="三-决策树算法和随机森林算法"><a href="#三-决策树算法和随机森林算法" class="headerlink" title="三.决策树算法和随机森林算法"></a>三.<strong>决策树算法和随机森林算法</strong></h1><h2 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a><strong>决策树算法</strong></h2><h3 id="决策树算法的特征"><a href="#决策树算法的特征" class="headerlink" title="决策树算法的特征"></a>决策树算法的特征</h3><p>通过对样本特征进行一系列“是”或“否”的判断，进而做出决策。</p><p>例如：家里长辈家孩子要过生日了，送什么礼物呢？</p><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626112017416.png"></p><h3 id="决策树的优势与不足"><a href="#决策树的优势与不足" class="headerlink" title="决策树的优势与不足"></a><strong>决策树的优势与不足</strong></h3><ul><li><p>优势</p><ul><li>可以清晰直观的将其工作过程可视化，可理解性强。</li><li>在训练的过程中对每个特征的处理都是相互独立的，各个特征之间不会相互干扰。</li></ul></li><li><p>不足</p><ul><li>容易出现过拟合问题，max_depth可以解决一定的过拟合问题， 但取值过低又可能造成模型的准确率降低。</li></ul></li></ul><h2 id="随机森林算法"><a href="#随机森林算法" class="headerlink" title="随机森林算法"></a><strong>随机森林算法</strong></h2><h3 id="随机森林与决策树模型的差异"><a href="#随机森林与决策树模型的差异" class="headerlink" title="随机森林与决策树模型的差异"></a>随机森林与决策树模型的差异</h3><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626112908489.png" alt="随机森林与决策树模型的差异"></p><h3 id="随机森林的优势与不足"><a href="#随机森林的优势与不足" class="headerlink" title="随机森林的优势与不足"></a><strong>随机森林的优势与不足</strong></h3><ul><li><p>优势</p><ul><li>几乎具有决策树所有的优势，且跟决策树相比，更不容易出现过拟合。</li><li>随机森林支持并行处理。</li></ul></li><li><p>不足</p><ul><li>可视化方面，随机森林不及决策树简单直接。</li><li>对于样本特征非常稀疏的数据来说，随机森林表现往往不如线性模型。</li><li>占用内存较大，训练速度较慢。</li></ul></li></ul><h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a><strong>基本原理</strong></h3><p>支持向量机是一种常见的机器学习算法，用于分类和回归问题。它基于一种将数据映射到高维空间的方法，然后通过寻找最适合分离不同类别的超平面来完成分类。该算法的核心思想是找到能够最大程度地将不同类别数据间隔开的超平面，并在这个超平面上选取一些支持向量来进行分类。在实际应用中，支持向量机在数据维度高、数据量大的情况下表现出色。</p><ul><li>数据集，可以分为线性可分和线性不可分数据集。</li></ul><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626113240090.png"></p><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626113315731.png"></p><h3 id="支持向量机的优势与不足"><a href="#支持向量机的优势与不足" class="headerlink" title="支持向量机的优势与不足"></a><strong>支持向量机的优势与不足</strong></h3><ul><li>优势<ul><li>神经网络走红之前，支持向量机风靡一时，通过gamma参数和c参数的调节，甚至可以生成比较复杂的模型处理复杂的图像问题。</li></ul></li><li>不足<ul><li>性能上，数据集规模大时，比较消耗内存，训练时间长。</li><li>建模过程不如决策树清晰易懂。</li><li>对数据预处理要求较高。</li></ul></li></ul><h2 id="分类模型的评价标准"><a href="#分类模型的评价标准" class="headerlink" title="分类模型的评价标准"></a>分类模型的评价标准</h2><h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p>混淆矩阵是用来总结一个分类器结果的矩阵。对于最常见的二元分类来说，它的混淆矩阵是2乘2的，如下：</p><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626115911785.png" alt="混淆矩阵"></p><p>TP：预测正确的正例数</p><p>FN：预测错误的正例数</p><p>FP：预测错误的负例数</p><p>TN：预测正确的负例数</p><h3 id="常用评价标准的概念"><a href="#常用评价标准的概念" class="headerlink" title="常用评价标准的概念"></a>常用评价标准的概念</h3><ul><li><p>准确率（Precision）</p><ul><li><p>表示模型预测正确的正例样本TP占所有预测为正例样本（TP+FP）的比例，公式为：</p><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626120031069.png" alt="Precision"></p></li></ul></li><li><p>召回率（Recall）</p><ul><li><p>也被称为查全率，是在所有实际为正例的样本（TP+FN）中，被正确预测为正例的样本比例，公式为：</p><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626120123758.png" alt="Recall"></p></li></ul></li><li><p>f1分数（F1 Score）</p><ul><li><p>平衡f分数，将准确率和召回率这两个分值合并为一个分值，合并过程中，认为召回率和准确率同等重要，公式为：</p><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626120202786.png" alt="F1 Score"></p></li></ul></li><li><p>ROC和AUC</p></li><li><p>真正类率TPR: TP&#x2F;(TP+FN),代表分类器预测的正类中实际正实例占所有正实例的比例。Sensitivit</p></li><li><p>负正类率FPR: FP&#x2F;(FP+TN)，代表分类器预测的正类中实际负实例占所有负实例的比例。1-Specificity</p></li><li><p>真负类率TNR: TN&#x2F;(FP+TN),代表分类器预测的负类中实际负实例占所有负实例的比例，TNR&#x3D;1-FPR。</p></li><li><p>ROC 指的是受试者工作特征缺陷，反应敏感性与特异性关系的曲线。</p></li><li><p>横轴FPR：负正类率特异度，划分实例中所有负例占所有负例的比例，FPR越大，预测正类中实际负类越多</p></li><li><p>纵轴TPR：真正类率灵敏度，TPR越大，预测正类中实际正类越多</p></li><li><p>AUC 指的是曲线ROC下方的面积，用来表示预测准确率，AUC越高，曲线下方面积越大，说明准确率越高，曲线约接近左上角。</p><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/image-20230626120411471.png"></p></li></ul><h1 id="小记总结"><a href="#小记总结" class="headerlink" title="小记总结"></a>小记总结</h1><ul><li><p>什么是监督学习</p><ul><li>通过让机器学习大量带有标签的样本，训练一个可以根据输入得到相应输出的模型。</li></ul></li><li><p>什么是无监督学习</p><ul><li>无监督学习是一种机器学习的训练方式，在没有标签的数据里可以发现潜在的一些结构的一种训练方式。</li></ul></li><li><p>什么是分类</p><ul><li>是一种监督学习，输出变量为有限个离散变量的预测问题为分类问题。</li></ul></li><li><p>什么是回归</p><ul><li>是一种监督学习，输出变量为连续数值型的预测问题为回归问题。</li></ul></li><li><p>决策树算法的优缺点</p><ul><li>优势，清晰直观的进行工作可视化，解释性好；对数据预处理相对不严格，缺点，容易过拟合</li></ul></li><li><p>什么是线性可分问题</p><ul><li>可以用一个线性函数把两类样本分开的问题</li></ul></li><li><p>什么是线性不可分问题</p><ul><li>不可以用一个线性函数把两类样本分开的问题</li></ul></li><li><p>在进行模型训练之前，对原始数据通常要进行哪些预处理，其常见方法有哪些？</p><ul><li>缺失值的处理，通常可以采用删除有缺失特征的样本（仅限于少量缺失的情况）；还可以采用临近样本的均值填充。</li><li>非字符型特征的处理，通常采用独热编码（one hot）方式，将字符型特征转换为数值型。</li><li>离群值和异常值处理，对于显著距离整体样本中心的样本进行删除处理。</li></ul></li><li><p>对于分类问题，有哪些常用指标可以用来评估模型的性能，写出其计算公式？</p><ul><li><p>准确率 &#x3D; TP&#x2F;(TP+FP)；召回率 &#x3D; TP&#x2F;(TP+FN)；</p></li><li><p>F1 &#x3D; 2 * 准确率 * 召回率&#x2F;（准确率+召回率）</p><p>其中TP：预测正确的正例数，FN：预测错误的正例数，FP：预测错误的负例数，TN：预测正确的负例数</p></li></ul></li><li><p>对于回归问题，有哪些常用指标可以用来评估模型的性能，写出其计算公式？</p><ul><li><p>RMSE 均方根误差 ；</p><p>MAPE 平均百分比误差 。</p><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/a3569cd9f1ba63bc739d674662e1a946.png" alt="img"></p><p><img src="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/366252c0b31d18c0409a287df64423ba-1687751398068-5.png" alt="MAPE"></p></li></ul></li><li><p>分类实验中，正样本和负样本的比率差异特别大时，可以采用什么方法尽量提高模型性能？</p><ul><li>可以从数量大的类别中随机挑选同数量少的类别相近的样本，然后进行训练。</li><li>可以随机重复从类别少的样本中重复抽取样本，直至总数和类别多的样本相近为止。</li></ul></li><li><p>什么是过拟合？</p><ul><li>训练数据上能够获得较好的拟合， 但是在训练数据外的数据集上却不能很好地拟合数据，此时认为这个假设出现了过拟合的现象。出现这种现象的主要原因是训练数据中存在噪音或者训练数据太少</li></ul></li><li><p>什么是欠拟合？</p><ul><li>对于训练好的模型，若在<a href="https://baike.baidu.com/item/%E8%AE%AD%E7%BB%83%E9%9B%86/205998?fromModule=lemma_inlink">训练集</a>表现差，在测试集表现同样会很差，这可能是欠拟合导致。欠拟合是指模型拟合程度不高，数据距离拟合曲线较远，或指模型没有很好地捕捉到数据特征，不能够很好地拟合数据。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>人工智能</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求职规划</title>
    <link href="/2023/06/24/%E6%B1%82%E8%81%8C%E8%A7%84%E5%88%92/"/>
    <url>/2023/06/24/%E6%B1%82%E8%81%8C%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="1-学习计划"><a href="#1-学习计划" class="headerlink" title="1.学习计划"></a>1.<strong>学习计划</strong></h1><p><img src="/2023/06/24/%E6%B1%82%E8%81%8C%E8%A7%84%E5%88%92/image-20230624110035295.png" alt="image-20230624110035295"></p><h1 id="2-简历指导"><a href="#2-简历指导" class="headerlink" title="2.简历指导"></a><strong>2.简历指导</strong></h1><p><strong>简历字数并非越多越好，任何关键词都可能引起面试官的考察兴趣</strong></p><ul><li><p>基础信息：</p><ul><li>书写顺序：个人信息-&gt;教育经历（获奖经历）-&gt;专业技能-&gt;<strong>实习（而非工作）</strong>经历-&gt;项目经验</li><li>文件名：姓名-院校-电话</li><li>文件格式：pdf（word排版会乱）</li><li>模版：冷色调、不要表格</li></ul></li><li><p>基本信息：<em>求职意向</em>、电话、出生年月、邮箱、<em>照片</em></p><ul><li>个人博客&#x2F;Github视情况而定</li><li>邮箱：必须为常用邮箱</li><li>意向城市：强需求可以填写</li></ul></li><li><p>教育经历：学校、专业、学历、<strong>时间区间</strong></p><ul><li>主修课程：经得住问，可以写</li><li>竞赛经历：算法题难度增加</li></ul></li><li><p>专业技能：<strong>精通</strong> &gt; 熟悉 &gt; 熟练使用&#x3D;掌握 &gt; 了解</p><ul><li>专注<ul><li>不能同时熟悉Java、C++</li></ul></li><li>不能同时熟悉MySQL、Oracle</li><li>不要存在单词错误、大小写错误</li><li>结构层次、分门别类</li><li>数据结构与算法不建议提及</li><li>不建议出现的关键词：深入、精通、扎实、经验丰富</li></ul></li><li><p>自我评价：不需要</p></li></ul><p><strong>目的：让面试官快速了解项目背景，与面试官有的聊</strong></p><ul><li><p>项目来源：【1-2要标明清楚】</p><ul><li><p>实习经历的项目</p></li><li><p>学校的生产项目（学校的XX系统）</p></li><li><p>学校的课程设计 或者 练手项目</p></li></ul></li><li><p>项目数量：2-3个</p></li><li><p>项目 &#x3D; 产品 + 技术 + 结果（传达给简历阅读者的信息）</p><ul><li>项目描述：做了什么产品</li><li>技术栈：用到了什么技术<strong>（与专业技能相辅相成）</strong></li><li>取得了什么结果<ul><li>规模（量化指标）：用户规模，资金规模等<ul><li>若规模较大&#x2F;场景较为明显，要想好“如何支撑”</li></ul></li><li>角色：主导者、参与者<ul><li>作为参与者，可以适当包装，但要清楚细节</li><li>作为主导者，可以讲明带领的团队人数</li></ul></li><li>推荐描述方式：<ul><li>通过XXX实现XXX，达到XX效果</li></ul></li></ul></li></ul></li><li><p>项目书写其他技巧：</p><ul><li>按照时间倒序写</li><li>详细的项目描述将亮点写在前面</li><li>岗位无关的项目尽量少写</li></ul></li><li><p><strong>建议的项目描述模版</strong></p></li></ul><p>项目名称                      所属组织&#x2F;公司                               时间区间</p><p>项目描述： 2-5句话内描述清楚主要功能。</p><p>角色：参与者&#x2F;主导者</p><p>技术栈：A、B、C、D、E、F（重要的放前面）</p><ol><li><p>通过X实现了Y，达到了Z的效果</p></li><li><p>通过X实现了Y，达到了Z的效果</p></li><li><p>通过X实现了Y，达到了Z的效果</p></li><li><p>通过X实现了Y，达到了Z的效果</p></li></ol><p>[个数：3-6]</p><h1 id="3-学习方法"><a href="#3-学习方法" class="headerlink" title="3.学习方法"></a>3.学习方法</h1><p><img src="/2023/06/24/%E6%B1%82%E8%81%8C%E8%A7%84%E5%88%92/image-20230624110406108.png" alt="image-20230624110406108"></p><p><img src="/2023/06/24/%E6%B1%82%E8%81%8C%E8%A7%84%E5%88%92/image-20230624110428930.png" alt="image-20230624110428930"></p><h1 id="4-知识图谱"><a href="#4-知识图谱" class="headerlink" title="4.知识图谱"></a><strong>4.知识图谱</strong></h1><p><img src="/2023/06/24/%E6%B1%82%E8%81%8C%E8%A7%84%E5%88%92/4adf3b8e-6786-4fc8-892b-521ca5e4edaf.png"></p><p><strong>红色：高频考点</strong></p><p><strong>橙色：中频考点</strong></p><p><strong>黑色：低频考点</strong></p><h1 id="5-附录"><a href="#5-附录" class="headerlink" title="5.附录"></a><strong>5.附录</strong></h1><p><strong>书籍推荐</strong></p><p>关于看书学习&#x2F;上网学习的几点建议：</p><ol><li>写的比较好的书是前后逻辑是很强的，利于理解。网上的博文的作者不一定有毅力坚持，往往烂尾，且天下文章一大抄，其中的错误可能被广为流传。</li><li>背面试题 vs 技术理解：一个是招式，一个是内功，相辅相成，缺一不可。</li><li>购买前查看简介，基于的版本，是不是如今的主流版本。</li><li>针对于“比较新的又没有大规模实践的”技术的书籍可以不买，看官方文档。</li></ol><p>刷题：</p><ul><li>理解：《漫画算法 小灰的算法之旅》</li><li>刷题：《剑指Offer》</li></ul><p>Java基础：</p><ul><li>大杂烩基础：《Effective Java》（第三版）</li><li>并发：《Java并发编程实战》</li><li>JVM：《深入理解Java虚拟机》（第三版）</li></ul><p>Mysql：</p><ul><li>进阶：《MySQL技术内幕:InnoDB存储引擎》</li></ul><p>Linux：</p><ul><li>鸟哥的Linux私房菜（基础学习篇）</li></ul><p>视野拓宽与技术理解：</p><ul><li>《码农翻身》</li><li>《代码整洁之道》</li><li>《重构：改善既有代码的设计》</li><li>《领域驱动设计》</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引原理</title>
    <link href="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    <url>/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Mysql概述"><a href="#1-Mysql概述" class="headerlink" title="1.Mysql概述"></a>1.Mysql概述</h1><ul><li><p>介绍：Oracle旗下开源的最流行的关系型数据库（Relational Database Management System）管理系统。</p></li><li><p>常见面试题：</p><ul><li>SQL与Mysql区别：<ul><li>SQL(Structured Query Language)是一种查询数据库的标准计算机语言，可以查询关系型数据库，包括但不限于Mysql。</li><li>Mysql是关系型数据库，支持SQL语言，但不支持全部的SQL（例如full outer join）</li></ul></li><li>Mysql与Oracle使用场景区别：<ul><li>错误答案：大公司用Oracle，小公司用mysql</li><li>正确答案：金融场景会使用Oracle</li></ul></li><li>RDMS与NoSQL的主要区别：<ul><li>强一致性、弱一致性</li><li>不可水平拓展、可水平拓展</li></ul></li><li>NewSQL：可水平扩展的RDMS，代替“中间件+关系型数据库分库分表”，例如TiDB、OceanBase</li><li>DML、DDL、DCL：数据操作语言、数据定义语言、数据控制语言</li></ul></li><li><p>客户端与服务端通讯方式：</p><ul><li>TCP&#x2F;IP</li><li>命名管道和共享内存【Windows】</li><li>Unix域套接字文件【Unix系】</li></ul></li></ul><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/43c52a51-111e-4fda-89b0-dda8f5d1414a.png" alt="MySQL逻辑层次图"></p><p><strong>MysqlServer层：连接管理、解析与优化</strong> </p><ul><li>查询缓存：5.7.20不推荐，8.0删除<ul><li>表的任何变动都会失效</li><li>前后两次查询SQL完全一致</li></ul></li><li>语法解析</li><li>查询优化：<strong>执行计划等（EXPLAIN）</strong></li></ul><p><strong>存储引擎层：</strong>负责数据的存储和提取。</p><ul><li><strong>InnoDB</strong>：默认且最为常用</li><li><strong>MyISAM</strong></li><li>其他存储引擎：Memory、Archive等</li></ul><p><strong>查询计划是MysqlServer层的职责，不跟随存储引擎而改变</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Mysql提供给存储引擎需要实现的接口实例（部分）：<br><br><span class="hljs-comment">//使用索引前调用该方法</span><br><br><span class="hljs-built_in">int</span> ha_foo::index<span class="hljs-constructor">_init(<span class="hljs-params">uint</span> <span class="hljs-params">keynr</span>, <span class="hljs-params">bool</span> <span class="hljs-params">sorted</span>)</span> <br><br><span class="hljs-comment">//使用索引后调用该方法</span><br><br><span class="hljs-built_in">int</span> ha_foo::index<span class="hljs-constructor">_end(<span class="hljs-params">uint</span> <span class="hljs-params">keynr</span>, <span class="hljs-params">bool</span> <span class="hljs-params">sorted</span>)</span><br><br><span class="hljs-comment">//读取索引第一条内容</span><br><br><span class="hljs-built_in">int</span> ha<span class="hljs-constructor">_index_first(<span class="hljs-params">uchar</span> <span class="hljs-operator">*</span> <span class="hljs-params">buf</span>)</span>;<br><br><span class="hljs-comment">//读取索引下一条内容</span><br><br><span class="hljs-built_in">int</span> ha<span class="hljs-constructor">_index_next(<span class="hljs-params">uchar</span> <span class="hljs-operator">*</span> <span class="hljs-params">buf</span>)</span>;<br><br><span class="hljs-comment">//读取索引前一条内容</span><br><br><span class="hljs-built_in">int</span> ha<span class="hljs-constructor">_index_prev(<span class="hljs-params">uchar</span> <span class="hljs-operator">*</span> <span class="hljs-params">buf</span>)</span>;<br><br><span class="hljs-comment">//读取索引最后一条内容</span><br><br><span class="hljs-built_in">int</span> ha<span class="hljs-constructor">_index_last(<span class="hljs-params">uchar</span> <span class="hljs-operator">*</span> <span class="hljs-params">buf</span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li>Innodb与Myisam引擎的区别</li></ul><p>Myisam：支持表锁；不支持外键，事务；表的索引与数据在不同的文件；支持全文索引；允许没有主键</p><p>Innodb：支持行锁、表锁；支持外键，事务；表索引与数据在同一的文件；不支持全文索引（5.6+开始支持）；会有默认主键</p><ul><li>数据库的1NF、2NF、3NF：</li></ul><p>1NF：关系中每一分量不可再分。即不能以集合、序列等作为属性。大白话：列不能存多个属性</p><p>2NF：在1NF基础上，消除非主属性对键的部分依赖。大白话：不同实体的表不要存在一张表里</p><p>3NF：在2NF基础上，消除非主属性对键的传递依赖。大白话：不要有重复字段</p><h1 id="2-Mysql索引概述"><a href="#2-Mysql索引概述" class="headerlink" title="2.Mysql索引概述"></a>2.Mysql索引概述</h1><ul><li><p>What？</p><ul><li>帮助Mysql高效获取数据的数据结构。</li></ul></li><li><p>Why？</p><ul><li>加快查询速度。（否则只能全表扫描）</li><li>代价：额外的存储空间</li></ul></li><li><p>How？</p><ul><li>增：CREATE  &lt;索引类型&gt; INDEX &lt;索引的名字&gt; ON <table_name>(列的列表)；</li><li>删：DROP INDEX <index_name> ON <table_name>;</li><li>查：SHOW INDEX FROM <table_name>;</li><li><strong>强制指定索引</strong>：select &lt;列名&gt; from <table_name>  where &lt;查询条件&gt; force index(${index_name})</li></ul></li></ul><p>面试题1：当mysql执行计划选择错了索引，怎么办？</p><p>面试题2（非主流）：一个表最多可以可以新建多少个索引？16个？谈谈你对这个限制的理解</p><h2 id="Mysql索引类别【重点】"><a href="#Mysql索引类别【重点】" class="headerlink" title="Mysql索引类别【重点】"></a>Mysql索引类别【重点】</h2><ul><li><p>按照实现的数据结构区分：</p><ul><li><strong>B+树</strong>索引（InnoDB,MyISAM存储引擎）</li><li>Hash索引（Memory存储引擎等）</li><li>倒排索引（ InnoDB,MyISAM存储引擎针对全文索引）</li><li>LSM-Tree索引：Hbase、OceanBase的索引数据结构</li></ul></li><li><p>按照约束（或者创建语句）区分：</p><ul><li>普通索引： CREATE  INDEX</li><li>唯一索引： CREATE  UNIQUE INDEX</li><li>主键索引： 创建表自带， { PRIMARY KEY (<code>id</code>) }</li><li>全文索引： CREATE  FULLTEXT INDEX<strong>【没人用，ES替代】</strong></li></ul></li><li><p>按照索引列的数量区分：</p><ul><li>单列索引</li><li>联合索引（复合索引、组合索引）【最左匹配原则】</li></ul></li><li><p>按照存储的内容区分(innodb存储引擎)</p><ul><li>聚簇索引：存储了索引列与数据【索引即数据，数据即索引】</li><li>非聚簇索引（辅助索引&#x2F;二级索引）：存储了索引列与主键</li></ul></li></ul><p>检查理解情况：（判断题）</p><ol><li>主键索引是单列索引，也是聚餐索引。</li><li>使用CREATE INDEX语句创建的索引均为辅助索引。</li><li>聚餐索引存储了mysql表的所有的数据，支持按照主键查询。</li><li>使用Innodb存储引擎的表的主键索引是B+树索引。</li><li>使用Innodb存储引擎的表聚簇索引与非聚餐索引均采用B+树索引，存储原理是一致的。</li></ol><p><strong>注意：</strong></p><p>只有B树，B+树</p><p>B-树 &#x3D; B树，<strong>不要读B减树</strong></p><ul><li><p>面试题1：Key（键&#x2F;约束）与Index（索引）的区别与联系：</p><ul><li>Index：方便查询</li><li>Key：方便查询 + 约束（主键、唯一键、外键）</li></ul></li><li><p>最左匹配原则:以最左边的为起点任何连续的索引都可匹配</p></li><li><p>面试题2：</p></li><li><p>索引：index(a, b, c )</p></li><li><p>以下查询语句是否可以使用此索引：</p></li></ul><ol><li>where a &#x3D; 1：ok</li><li>where a &#x3D; 1 and c &#x3D; 1：索引效果与上面一样</li><li>where b &#x3D; 1：不ok</li><li>where a &#x3D; 1 and b &#x3D; 1 ：ok</li><li><strong>where b &#x3D; 1 and a &#x3D; 1：k【与条件先后顺序无关】</strong></li></ol><ul><li>面试题3：有哪些索引？</li></ul><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><ul><li>mysql innodb等值查询除了会使用到B+树索引，还可能使用到什么索引？</li><li>谈谈哈希索引（自适应hash索引）<ul><li>哈希索引适合等值查询，但是无法进行范围查询</li><li>哈希索引没办法利用索引完成排序 </li><li>哈希索引不支持多列联合索引的最左匹配规则 </li><li>如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题</li><li>由innodb自行建立维护，DBA无法介入</li></ul></li><li>谈谈哈希索引与B+树索引的区别？</li></ul><h1 id="3-Innodb记录格式"><a href="#3-Innodb记录格式" class="headerlink" title="3.Innodb记录格式"></a>3.Innodb记录格式</h1><p><strong>行格式：</strong></p><ul><li><p>What 行？</p><ul><li>执行 insert into <table_name> values(&lt;值&gt;) 语句便向数据库插入了一条数据，此条数据称之为行或者记录</li></ul></li><li><p>What 行格式？</p><ul><li>存储上述行（或记录）在磁盘上的存放方式，即行格式&#x2F;记录格式</li></ul></li><li><p>How 行格式？</p><ul><li>指定：CREATE TABLE 表名 (列的信息) ROW_FORMAT&#x3D;行格式名称</li><li>修改：ALTER TABLE 表名 ROW_FORMAT&#x3D;行格式名称</li></ul></li><li><p>行格式的类型有哪些？</p><ul><li>Redundant：5.0-，冗余行格式，远古时期</li><li>Compact：5.6默认</li><li><strong>Dynamic</strong>：5.7+默认，动态行格式，和Compact区别不大，仅在行溢出情况下存在区别</li><li>Compressed：压缩行格式，采用压缩算法节约磁盘空间，仅在数据归档时才会使用</li></ul></li></ul><p><strong>Dynamic行格式【重点】</strong></p><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/3cd7d80a-ad09-489e-a1b6-c7aeac85cad1.png" alt="示意图"></p><p><strong>记录存储在“页”中，一页16KB</strong></p><p>记录的额外信息：</p><ul><li>变长字段长度列表：变长字段（占用存储字节数不固定的字段，例如VARCHAR）的实际长度</li><li>NULL值列表：<ul><li>标示了哪些列：主键列、被NOT NULL修饰的列都是不可以存储NULL值，其他都存储</li><li>如何标示：二进制位的值为1时，代表该列的值为NULL；二进制位的值为0时，代表该列的值不为NULL</li><li>占用的字节数：必须用整数个字节的位表示（如果使用的二进制位个数不是整数个字节，则在字节的高位补0）</li></ul></li><li>记录头信息：占用5个字节（40位）<ul><li><strong>delete_mask：该记录是否被删除</strong></li><li><strong>next_record：下一条记录的相对位置（并不是插入顺序的下一条记录，而是按照主键值&#x2F;索引列值的下一条记录）</strong></li><li>record_type：记录类型， 0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li><li>heap_no：当前记录所属的<strong>页</strong>号</li><li>其他（预留位1、预留位2、 min_rec_mask、 n_owned）</li></ul></li></ul><p>记录的真实数据：</p><ul><li>隐藏列：<ul><li><strong>row_id</strong>：行ID，非必须，无主键且无NOT NULL的UK时才会有</li><li>transaction_id：事务ID</li><li>roll_pointer：回滚指针</li></ul></li><li>数据列：存储真实的数据</li></ul><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/84d18ac1-f7c3-49be-b533-28b7ccae069e.png" alt="示意图2"></p><p>其他概念-行溢出：当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中的现象</p><p>面试题1：delete语句之后，空间会不会自动释放？</p><p>答：不会，会将此记录标记为己删除，页内已删除的记录做为一个<strong>垃圾链表</strong>，下次需要向此页插入数据时，优先使用此块空间。</p><p>面试题2：表创建时无主键，会怎么办？</p><p>答：</p><ol><li>首先选择第一个被NOT NULL修饰的UK索引做为聚簇索引</li><li>若无，则会在记录中添加隐藏列的row_id</li></ol><p>面试题3：为什么查询数据时不建议select *</p><ol><li>网络IO  2.  发生回表现象   3.  回表时命中溢出页</li></ol><h1 id="4-Innodb页格式"><a href="#4-Innodb页格式" class="headerlink" title="4.Innodb页格式"></a>4.Innodb页格式</h1><h2 id="索引页-x2F-数据页"><a href="#索引页-x2F-数据页" class="headerlink" title="索引页&#x2F;数据页"></a>索引页&#x2F;数据页</h2><p>页： InnoDB管理存储空间的基本单位，也是MySQL中磁盘和内存交互的基本单位，一个页的大小一般是16KB</p><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/49278afe-ad09-402b-b1d2-f47bbf9820aa.png" alt="数据页/索引页格式示意图"></p><ul><li><p>文件头：File Header，页的一些通用信息</p><ul><li>页号</li><li>校验和：与页尾一起校验页是否完整，刷盘时首先写校验和，通过和文件尾的校验和一同判断是否存在同步一半的情况。</li><li><strong>上一个页的页号、下一个页的页号：组成B+树的双向链表</strong></li></ul></li><li><p>页头：Page Header，数据页专有的一些信息</p><ul><li>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</li><li><strong>第一个已经标记为删除的记录地址【为了找到垃圾链表，插入数据】</strong></li><li><strong>还未使用的空间最小地址【为了插入数据】</strong></li><li>页类型等其他</li></ul></li><li><p><em>虚记录</em>：最小虚记录和最大虚记录</p><ul><li>最小虚记录：此记录的next_record指向本页中最小的记录</li><li>最大虚记录：指向本页中最大的记录的next_record指向此记录</li></ul></li><li><p><em>用户记录</em>*&#x2F;*<em>记录堆</em>：实际存储的记录内容，由一堆行记录组成</p><ul><li>既有有效记录，又有已删除的记录</li></ul></li><li><p>未分配空间：页中尚未使用的空间</p><ul><li>下次需要向此页插入数据时，若无垃圾链表，则会使用此块空间。</li></ul></li><li><p><em>页目录</em><em>&#x2F;Slot**区</em>：页中的某些记录的相对位置，为了快速查询</p></li><li><p>文件尾：与页头一起校验页是否完整</p></li></ul><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/9ee83e74-fffd-4868-a7a9-78da7001cb1b.png" alt="示意图3"></p><h2 id="记录的页内插入"><a href="#记录的页内插入" class="headerlink" title="记录的页内插入"></a>记录的页内插入</h2><ul><li><p>插入位置：</p><ul><li>垃圾链表（页头记录了第一个已经标记为删除的记录地址）</li><li>未分配的空间（页头记录了还未使用的空间最小地址）</li></ul></li><li><p>插入策略：物理有序 vs 逻辑有序</p><ul><li>举例：依次插入顺序10、9、8</li></ul><p>物理有序：</p></li></ul><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/c603392e-8c89-44f1-992d-ee36fa0f21a2.png" alt="物理有序"></p><p>逻辑有序：</p><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/98dadc07-8cf8-4362-9403-1e80d1a4904d.png" alt="逻辑有序"></p><h2 id="记录的页分裂【重点】"><a href="#记录的页分裂【重点】" class="headerlink" title="记录的页分裂【重点】"></a>记录的页分裂【重点】</h2><ul><li>该页装不下怎么办？假设页10只能装下3条记录，现在要插入id&#x3D;4的记录</li></ul><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/image-20230624094252434.png" alt="image-20230624094252434"></p><p>思考：<strong>为什么mysql主键不建议使用UUID</strong></p><ul><li>在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>。这个过程我们也可以称为页分裂。</li></ul><h2 id="记录的页内查找（了解）"><a href="#记录的页内查找（了解）" class="headerlink" title="记录的页内查找（了解）"></a><strong>记录的页内查找（了解）</strong></h2><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/image-20230624094451483.png" alt="image-20230624094451483"></p><p><strong>问：此时查找id&#x3D;3的数据的时间复杂度是多少？</strong></p><h2 id="记录的页内二分查找（了解）"><a href="#记录的页内二分查找（了解）" class="headerlink" title="记录的页内二分查找（了解）"></a><strong>记录的页内二分查找（了解）</strong></h2><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/336a7b3f-3469-4bb8-9592-2c2584412b95.png"></p><ul><li>Slot区：也称Page Directory区，页<strong>目录</strong>区，记录页中的某些记录的相对位置。</li><li>Slot：槽，对于页内记录（含最大记录与最小记录，不包括标记为已删除的记录）进行<strong>分组</strong>，每个组的最后一条记录的地址偏移量即为槽。<ul><li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录</li></ul></li></ul><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/5acc62c9-e566-4504-9058-08543f2d65ce.jpeg"></p><ul><li><p>分组依据：</p><ul><li>对于最小记录所在的分组只能有 1 条记录</li><li>最大记录所在的分组拥有的记录条数只能在 1~8 条之间</li><li>剩下的分组中记录的条数范围只能在是 4~8 条之间</li></ul></li><li><p>如何二分查找：O(Log2N)</p><ul><li><p>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录二分过程：(high槽 + low槽) &#x2F; 2 得到当前槽，判断当前槽所指记录的大小，决定high&#x2F;low的变化查找主键值最小的那条记录：(high – 1)槽所指的记录的next_record</p></li><li><p>通过记录的next_record属性遍历该槽所在的组中的各个记录</p></li></ul></li></ul><h2 id="5-再看B-树索引【重点】"><a href="#5-再看B-树索引【重点】" class="headerlink" title="5.再看B+树索引【重点】"></a>5.<strong>再看B+树索引【重点】</strong></h2><p><strong>B+树聚簇索引</strong></p><ul><li><ol><li>页之间存在双向链表（通过页的文件头区域的“上一页的页号”与“下一页”页号）</li></ol><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/image-20230624095018218.png" alt="image-20230624095018218"></p></li></ul><p>此时查找办法：从左到右遍历页，看当前记录是否在最小记录与最大记录之间，若不在则判断下一页，若在则在页内二分查找。</p><ul><li><ol start="2"><li>给每个页建立个目录，记录“页的用户记录中最小的主键值”与页号</li></ol><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/image-20230624095038737.png" alt="image-20230624095038737"></p></li></ul><p>此时的查找方法：在目录页二分查找（距离此记录最近的所在的页），再在目标页内，二分查找。</p><ul><li><ol start="3"><li>“目录”太多，一页装不下，分多个页来装。</li></ol><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/a84807a4-42fb-4477-adfc-5ab136b63556.png"></p></li></ul><p>此时的查找方法：先从根页查找“距离此记录最近的记录”所在的页，再到索引页“距离此记录最近的记录”，最后到叶子节点二分查找</p><ul><li>根节点：存放索引信息（或者称为目录项）的页</li><li>非叶子节点（内节点）：存放索引信息的页<ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</li></ul></li><li>叶子节点（外节点）：存放索引信息与<strong>实际数据</strong>的页<ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</li></ul></li></ul><p>Innodb的聚簇索引与非聚簇索引均采用此结构进行存储，区别在于：</p><ol><li>聚簇索引的叶子节点存储的是全量数据</li><li>非聚簇索引的叶子节点存储的是索引列的值 + 主键</li></ol><p>下一个数据页中用户记录的索引列值必须<strong>大于</strong>上一个页中用户记录的索引列值。</p><p>&#x3D;&gt;  </p><p><strong>非聚簇索引的存储的索引数据一定会有主键</strong>。</p><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/62031496-6d9c-4051-8514-24edf4aa3b0c.png"></p><p>**如上图某非聚簇索引橙色为索引的key绿色为页号蓝色为主键 **</p><p>此时若插入索引key&#x3D;1的数据改插入到页4还是页5？</p><p>面试题：</p><p>表：user（id，name、sex）</p><p>查询条件： where name &#x3D; ？ and sex &#x3D;? order by id</p><p>为了高效查询，建立索引有4种方式，以下哪种最优？</p><ol><li>idx_name_sex_id（name、sex、id）</li><li>idx_sex_ name_ id （sex、name、id）</li><li>idx_sex_name（sex、name）</li><li>idx_name_sex （name、 sex）</li></ol><h1 id="6-索引的使用"><a href="#6-索引的使用" class="headerlink" title="6.索引的使用"></a>6.索引的使用</h1><h2 id="访问类型概述"><a href="#访问类型概述" class="headerlink" title="访问类型概述"></a>访问类型概述</h2><p>访问类型：也称访问方法，access method，MySQL执行查询语句的方式。</p><ul><li>使用全表扫描进行查询（all）</li><li>使用索引进行查询（const、ref、ref_or_null、range、index等）</li></ul><p>注意：<strong>数据量大的表，一定要避免all的发生</strong></p><h3 id="访问类型-const"><a href="#访问类型-const" class="headerlink" title="访问类型-const"></a>访问类型-const</h3><ul><li>const：<ul><li>直接利用主键值在聚簇索引中定位对应的一条记录</li><li>根据唯一辅助索引列来定位一条记录</li></ul></li></ul><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/73f050bf-37a5-48f4-9505-b22d818f2d2d.png"></p><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/06430fec-9f61-45d6-84a5-d6bd991416a9.png"></p><h3 id="访问类型-ref【重点】"><a href="#访问类型-ref【重点】" class="headerlink" title="访问类型-ref【重点】"></a>访问类型-ref【重点】</h3><ul><li>ref：对某个普通的二级索引列与常数进行等值比较</li></ul><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/268b086b-6fba-4728-b54c-a3d73a225074.png"></p><p>面试题：</p><ol><li>为什么不select *？</li><li>什么是索引覆盖？</li><li>为什么要尽量避免回表？</li></ol><h3 id="访问类型-ref-or-null"><a href="#访问类型-ref-or-null" class="headerlink" title="访问类型-ref_or_null"></a>访问类型-ref_or_null</h3><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/268b086b-6fba-4728-b54c-a3d73a225074-1687571895894-20.png"></p><h3 id="访问类型-range"><a href="#访问类型-range" class="headerlink" title="访问类型-range"></a>访问类型-range</h3><ul><li>range：区间查询，使用&#x3D;、&lt;&#x3D;&gt;、IN、NOT IN、IS NULL、IS NOT NULL、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、BETWEEN、!&#x3D;、 &lt;&gt;、like左匹配，就可以产生一个所谓的区间。</li></ul><p>举例：SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 &gt;&#x3D; 38 AND key2 &lt;&#x3D; 79);</p><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/image-20230624095852531.png" alt="image-20230624095852531"></p><h3 id="访问类型-index"><a href="#访问类型-index" class="headerlink" title="访问类型-index"></a>访问类型-index</h3><ul><li>index：查询的值以及返回的结果恰好在某个辅助索引里，但是无法通过索引列查询，全部扫描此索引。</li></ul><p>举例：</p><p>表：</p><p>CREATE TABLE single_table (</p><p>​    id INT NOT NULL AUTO_INCREMENT,</p><p>​    key1 VARCHAR(100),</p><p>​    key2 INT,</p><p>​    key3 VARCHAR(100),</p><p>​    key_part1 VARCHAR(100),</p><p>​    key_part2 VARCHAR(100),</p><p>​    key_part3 VARCHAR(100),</p><p>​    common_field VARCHAR(100),</p><p>​    PRIMARY KEY (id),</p><p>​    <strong>KEY</strong> <strong>idx_key_part(key_part1, key_part2, key_part3)</strong></p><p>) Engine&#x3D;InnoDB CHARSET&#x3D;utf8;</p><p>查询语句：SELECT <strong>key_part1, key_part2, key_part3</strong> FROM single_table WHERE key_part2 &#x3D; ‘abc’; </p><p>辅助索引的数据比聚簇索引的数据小，全表所描辅助索引，也是个不错的选择</p><h2 id="索引的注意事项"><a href="#索引的注意事项" class="headerlink" title="索引的注意事项"></a><strong>索引的注意事项</strong></h2><ol><li>ORDER BY子句里使用到了我们的索引列（但是 oder by a asc, b desc, c desc不行）</li><li>只为用于搜索、排序或分组的列创建索引</li><li>列的区分度大的列创建索引，重复数据多的字段不应设为索引</li><li>更新频繁的列不应设置索引</li><li>重复数据多的字段不应设为索引的例外情况（状态字段&#x3D;有效&#x2F;无效，仅根据“有效”查询时，可以建立）</li><li>联合索引，区分度大的列放在第一位</li><li>只有索引列在比较表达式中单独出现才可以适用索引 （ a &gt; 2 可以，a + 1 &gt; 1不行）</li><li>为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT属性。</li><li>尽量使用覆盖索引进行查询，避免回表带来的性能损耗。</li><li>使用IN查询，IN的数量不能太大（&lt;&#x3D;2000），避免mysql走错索引</li><li>Mysql会根据I&#x2F;O成本以及CPU成本去估算，选择最终执行计划</li><li>LIKE 右模糊（like kw%）可以使用到索引，LIKE左模糊（like %kw） 、全模糊（like %kw%）无法使用到索引。</li></ol><p>神兵利器：</p><ul><li><strong>EXPLAIN</strong>：查看SQL的执行计划的结果。</li><li>optimizer trace：查看生成执行计划的整个过程。</li></ul><p><strong>面试题：</strong></p><ol><li><strong>如何判断SQL走的是哪个索引？</strong></li><li><strong>如何优化慢SQL？</strong></li><li><strong>建立索引有哪些注意事项？</strong></li></ol><h1 id="7-其他应该知道的知识点"><a href="#7-其他应该知道的知识点" class="headerlink" title="7.其他应该知道的知识点"></a>7.其他应该知道的知识点</h1><h2 id="innodb区-x2F-段-x2F-表空间"><a href="#innodb区-x2F-段-x2F-表空间" class="headerlink" title="innodb区&#x2F;段&#x2F;表空间"></a>innodb区&#x2F;段&#x2F;表空间</h2><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/e436a165-a427-4505-b89d-c10cbe2ebb71.jpeg"></p><ul><li><p>区：连续的64个页就是一个区。</p><ul><li>设计的目的：一个区就是在物理位置上连续的64个页，物理连续，空间的局部性原理，发生连续IO几率更高。（利用磁盘预读原理）</li></ul></li><li><p>段：存储相同类型记录的区做为一个段，一个段会有256个区，一个表空间下会有多个段，如“叶子节点段”、“非叶子节点段”。</p><ul><li>设计的目的：范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣。物理连续，空间的局部性原理，发生连续IO几率更高。</li></ul></li><li><p>表空间：为了更好的管理页，一个.idb结尾的表为一个独立表空间。</p></li></ul><h2 id="为什么使用B-树，不用B树-x2F-二叉树？"><a href="#为什么使用B-树，不用B树-x2F-二叉树？" class="headerlink" title="为什么使用B+树，不用B树&#x2F;二叉树？"></a><strong>为什么使用B+树，不用B树&#x2F;二叉树？</strong></h2><ol><li>二叉树的高度太高，每次查找都是一次磁盘IO，很慢；B+树是一个多路查找树，高度一般2-4层，矮胖，IO较少。</li><li>B+树仅在叶子节点存储数据，叶子节点之间有双向链表，范围扫描快，B树没有，B树的非叶子节点也存储数据。</li></ol><h2 id="索引下推（ICP）"><a href="#索引下推（ICP）" class="headerlink" title="索引下推（ICP）"></a>索引下推（ICP）</h2><ul><li><p>索引下推：5.6+，有效减少回表次数，从而提高效率。</p></li><li><p>例子：</p><ul><li>语句：select * from table where k1 &#x3D; a and k2 &#x3D; b，索引为idx_k12(k1, k2)</li><li>执行：innodb扫描到一条记录：k1 &#x3D; a , k2 &#x3D; c<ul><li>不使用ICP：innodb将此记录返回给mysql-server， mysql-server拿着主键去回表判断 k2 是否等于 b</li><li>使用ICP：innodb自行判断，无需mysql-server回表判断</li></ul></li></ul></li><li><p>区别：</p><ul><li>当你不使用ICP,通过使用非主键索引（普通索引or二级索引）进行查询，存储引擎通过索引检索数据，然后返回给MySQL服务器，服务器再判断是否符合条件。</li><li>使用ICP，当存在索引的列做为判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。</li></ul></li></ul><p><strong>进阶面试题：5.6之前为什么不下推？</strong></p><p><strong>所谓下推，不过是将MysqlServer做的事情下移至存储引擎来做，其实是一个很正常的操作，只不过Mysql在之前的版本，并没有把这部分判断条件传递给存储引擎，过于简单粗暴。</strong></p><h2 id="深翻页"><a href="#深翻页" class="headerlink" title="深翻页"></a>深翻页</h2><ul><li>现象：select * from table_name limit m,n;  当m很大时，查询性能急剧下降。</li><li>第一层原理：先读取符合where条件的前面m+n条记录，然后抛弃前m条，返回后面n条，所以m越大，偏移量越大，性能就越差。</li><li>第二层原理：mysql server与存储引擎的交互，首先根据索引定位到第一条，往后一条条数据往后扫描，每条数据mysql server再判断是否要用，丢弃掉了前面m条数据。</li><li>解决方案：<ul><li>优化前：select * from table_a limit 1000000, 10;</li><li>优化后：select * from table_a where id &gt; ${lastKey} limit 10;</li></ul></li><li>解决方案的局限性：<ul><li>1、没有总页数</li><li>2、只能上下翻页</li><li>3、id必须有序且唯一</li></ul></li></ul><h2 id="面试题-情景题"><a href="#面试题-情景题" class="headerlink" title="面试题-情景题"></a>面试题-情景题</h2><ul><li><p>生产环境Mysql数据库所在服务器CPU飙升，如何排查？</p></li><li><p>经验：mysql服务器的CPU飙升往往都是慢SQL导致的</p></li><li><p>问题转换 &#x3D;&gt; 如何找到慢SQL？</p></li><li><p>方法1：查看数据库的慢SQL日志  slow.log</p></li><li><p>方法2：查看CPU飙升的曲线，是从时候开始的，那段时间做了什么样的代码变更，查看查询的表与条件。</p></li></ul><h2 id="面试题-Mysql单表最多能存储多少数据？"><a href="#面试题-Mysql单表最多能存储多少数据？" class="headerlink" title="面试题-Mysql单表最多能存储多少数据？"></a>面试题-Mysql单表最多能存储多少数据？</h2><ul><li>业内经验：<ul><li>阿里巴巴《Java开发手册》：单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</li><li>互联网圈流传：MySQL 单表数据量大于 2000 W行，性能会明显下降。</li></ul></li><li>Mysql单表最多能存储多少数据？<ul><li>理论上可存储多少：取决于主键的数据类型，int为2^32 - 1，bigint为2^64 - 1</li><li>实际上可存储多少：超过了多少将影响Mysql的性能</li></ul></li><li>分析：</li></ul><p>Mysql单表最多能存储多少数据？ &#x3D;&gt; Mysql单表数据量超过多少将较大的影响mysql的性能？</p><p>影响Mysql性能的主要原因是什么？&#x3D;&gt; 索引结构，B+树索引 &#x3D;&gt; B+树的什么属性影响了性能 &#x3D;&gt; 高度（一般2-3层，2-3次IO）</p><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/4ddd953d-850b-4b13-9e46-d1bdfa7aae1a.png"></p><p><img src="/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/a35c6b4a-a161-4ced-824b-65260247bd1f.png"></p><ul><li>如何理解业内经验？DBA基于大多数场景的经验</li></ul><h2 id="其他基础知识"><a href="#其他基础知识" class="headerlink" title="其他基础知识"></a>其他基础知识</h2><ul><li>表的字符集要使用，utf8mb4</li><li>表的比较规则要大小写敏感（默认不敏感），以_cs结尾的比较规则</li><li>union与union all的区别</li><li>char与varhcar的区别</li><li>左连接，右连接，内连接的区别</li><li>Mysql时间&#x2F;日期的数据类型：<a href="https://blog.51cto.com/u_15346415/3675766">https://blog.51cto.com/u_15346415/3675766</a></li><li>基础的SQL语句书写</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Java知识体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java知识体系树状图</title>
    <link href="/2023/06/24/Java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A0%91%E7%8A%B6%E5%9B%BE/"/>
    <url>/2023/06/24/Java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A0%91%E7%8A%B6%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<blockquote class="pullquote mindmap mindmap-md"><ul><li>Java知识体系<ul><li>Java<ul><li>基础<ul><li>数据类型（基本类型与装箱类型）</li><li>异常</li><li>OOP（封装继承多态）</li><li>泛型</li><li>反射</li></ul></li></ul></li><li>开发框架</li><li>中间件<ul><li>MySQL<ul><li>索引</li><li>事务</li><li>锁</li><li>分布式解决方案<ul><li>主从复制</li><li>读写分离</li><li>分库分表</li><li>分布式事务</li></ul></li></ul></li></ul></li><li>工程理论</li><li>工程体系</li><li>计算机基础</li></ul></li></ul></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_githubpages搭建博客</title>
    <link href="/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="win11-hexo-githubpages搭建博客"><a href="#win11-hexo-githubpages搭建博客" class="headerlink" title="win11_hexo_githubpages搭建博客"></a>win11_hexo_githubpages搭建博客</h1><h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 <a href="https://hexo.io/zh-cn/docs/index.html#%E5%AE%89%E8%A3%85-Hexo">安装 Hexo</a> 步骤。</p><p>如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>。</li></ul><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>安装成功后，将 git 与 GitHub 账号绑定，右键打开 Git Bash，然后设置配置信息：</p><p><img src="/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20230624014910133.png" alt="image-20230624014910133"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text"># 配置用户名和邮箱<br>git config --global user.name &quot;github 用户名&quot;<br>git config --global user.email &quot;github 注册邮箱&quot;<br></code></pre></td></tr></table></figure><p>比如我的配置就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">git config --global user.name <span class="hljs-string">&quot;qgc123&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;2467879337@qq.com&quot;</span><br></code></pre></td></tr></table></figure><p>接着生成 ssh 密钥文件，输入如下命令后直接三次回车即可，一般不需要设置密码；</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text"># 生成 ssh 密钥<br>ssh-keygen -t rsa -C &quot;github 注册邮箱&quot;<br></code></pre></td></tr></table></figure><p>我生成秘钥的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;2467879337@qq.com&quot;</span><br></code></pre></td></tr></table></figure><p>一般执行上述命令之后，会生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，前者是我们私有的，而后者则是对外开放的。接着找到生成的 <code>.ssh</code> 的文件夹中的 id_rsa.pub 密钥，将内容复制；</p><p>然后打开 <a href="https://link.zhihu.com/?target=https://github.com/settings/keys">GitHub-Settings-Keys</a> 页面，创建一个新的 SSH key，填写 <code>Title</code> 和 <code>Key</code>，<code>Title</code> 可以随意，而 <code>Key</code> 的内容则是我们刚才复制的 <code>id_rsa.pub</code> 中的内容，最后点击 <code>Add SSH key</code> 即可；</p><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>Node.js 为大多数平台提供了官方的 <a href="https://nodejs.org/zh-cn/download/">安装程序</a>。对于中国大陆地区用户，可以前往 <a href="https://npmmirror.com/mirrors/node/">淘宝 Node.js 镜像</a> 下载。</p><p>其它的安装方法：</p><ul><li>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者 <a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。</li></ul><p><strong>Windows 用户</strong></p><p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><h3 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h3><p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> hexo<br></code></pre></td></tr></table></figure><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><code>npx hexo &lt;command&gt;</code></li><li>Linux 用户可以将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27;</span> &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure><h3 id="Node-js-版本限制"><a href="#Node-js-版本限制" class="headerlink" title="Node.js 版本限制"></a>Node.js 版本限制</h3><p>如果你坚持使用旧的 Node.js，你可以考虑安装 Hexo 的过去版本。</p><p>请注意，我们不提供对过去版本 Hexo 的错误修复。</p><p>强烈建议永远安装 <a href="https://www.npmjs.com/package/hexo?activeTab=versions">最新版本</a> 的 Hexo，以及 <a href="https://hexo.io/zh-cn/docs/index.html#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">推荐的 Node.js 版本</a>。</p><table><thead><tr><th align="left">Hexo 版本</th><th align="left">最低版本 (Node.js 版本)</th><th align="left">最高版本 (Node.js 版本)</th></tr></thead><tbody><tr><td align="left">6.2+</td><td align="left">12.13.0</td><td align="left">latest</td></tr><tr><td align="left">6.0+</td><td align="left">12.13.0</td><td align="left">18.5.0</td></tr><tr><td align="left">5.0+</td><td align="left">10.13.0</td><td align="left">12.0.0</td></tr><tr><td align="left">4.1 - 4.2</td><td align="left">8.10</td><td align="left">10.0.0</td></tr><tr><td align="left">4.0</td><td align="left">8.6</td><td align="left">8.10.0</td></tr><tr><td align="left">3.3 - 3.9</td><td align="left">6.9</td><td align="left">8.0.0</td></tr><tr><td align="left">3.2 - 3.3</td><td align="left">0.12</td><td align="left">未知</td></tr><tr><td align="left">3.0 - 3.1</td><td align="left">0.10 或 iojs</td><td align="left">未知</td></tr><tr><td align="left">0.0.1 - 2.8</td><td align="left">0.10</td><td align="left">未知</td></tr></tbody></table><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>安装完成后，要查看我们是否安装成功，可以打开命令提示符（<code>Win + R</code>），输入 <code>cmd</code> 打开控制台，输入如下命令，如果出现对应版本号，说明安装成功了；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br>npm -v<br></code></pre></td></tr></table></figure><p><img src="/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20230624015114342.png" alt="image-20230624015114342"></p><h1 id="主题安装（fluid）："><a href="#主题安装（fluid）：" class="headerlink" title="主题安装（fluid）："></a>主题安装（fluid）：</h1><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h4 id="1-搭建-Hexo-博客"><a href="#1-搭建-Hexo-博客" class="headerlink" title="1. 搭建 Hexo 博客"></a>1. 搭建 Hexo 博客</h4><p>如果你还没有 Hexo 博客，请按照 <a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a> 进行安装、建站。</p><h4 id="2-获取主题最新版本"><a href="#2-获取主题最新版本" class="headerlink" title="2. 获取主题最新版本"></a>2. 获取主题最新版本</h4><p><strong>方式一：</strong></p><p>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a> 内容复制进去。</p><p><strong>方式二：</strong></p><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 themes 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><h4 id="3-指定主题"><a href="#3-指定主题" class="headerlink" title="3. 指定主题"></a>3. 指定主题</h4><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题</span><br><br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h4 id="4-创建「关于页」"><a href="#4-创建「关于页」" class="headerlink" title="4. 创建「关于页」"></a>4. 创建「关于页」</h4><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><p>其他参考<a href="https://hexo.fluid-dev.com/docs/">用户文档</a></p><h1 id="主题安装问题"><a href="#主题安装问题" class="headerlink" title="主题安装问题"></a>主题安装问题</h1><h2 id="报错：Error-Cannot-find-module-‘css’"><a href="#报错：Error-Cannot-find-module-‘css’" class="headerlink" title="报错：Error: Cannot find module ‘css’"></a>报错：Error: Cannot find module ‘css’</h2><p>只需要<br><code>npm install css --save</code></p><h1 id="插入图片问题"><a href="#插入图片问题" class="headerlink" title="插入图片问题"></a>插入图片问题</h1><h2 id="如何向hexo博客中插入图片"><a href="#如何向hexo博客中插入图片" class="headerlink" title="如何向hexo博客中插入图片"></a><strong>如何向hexo博客中插入图片</strong></h2><p>众所周知，在md文件中插入图片的语法为<code>![]()</code>。</p><p>其中<strong>方括号</strong>是图片描述，<strong>圆括号</strong>是图片路径。</p><p>一般来说有三种图片路径，分别是<strong>相对路径，绝对路径和网络路径</strong>。</p><p>所谓的网络路径就是直接引用网上的图片，直接复制图片地址，放在圆括号中就完事了。</p><p>这种方式十分的方便，但是也存在一定的问题：</p><ul><li>图片失效导致无法加载；</li><li>打开网页后要再请求加载图片；</li><li>原网站限制，如微信公众号的图片会变得不可见等。</li></ul><p>这种方式算是有利有弊。</p><p>绝对路径是图片在计算机中的绝对位置，相对路径是相对于当前文件的路径。</p><p>由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。</p><p>在hexo中使用<strong>文章资源文件夹</strong>需要在<code>config.yaml</code>文件中更改一下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>当该配置被应用后，使用<code>hexo new</code>命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。</p><blockquote><p>由于项目会生成新的文件目录，同时会解析Markdown中的图片路径，会导致一个问题。<br>如在一个文件目录下，博客名为<code>1.md</code>，相应的存在一个<code>1</code>文件夹存放图片<code>image.jpg</code>。<br>在Typora编辑器中，普通的md文件使用<code>![](1/image.jpg)</code>能在编辑器中正常显示图片。<br>在hexo中，按理说应该是使用<code>![](image.jpg)</code>，但网页中却无法正常显示。<br>此时应该使用这样的方式来引入图片：</p></blockquote><p>但是这样不方便。</p><h2 id="图片插件"><a href="#图片插件" class="headerlink" title="图片插件"></a><strong>图片插件</strong></h2><p>插件<a href="https://link.zhihu.com/?target=https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>解决了这个问题。可以只用<code>npm install hexo-renderer-marked</code>命令直接安装，之后在<code>config.yaml</code>中更改配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>之后就可以在使用<code>![](image.jpg)</code>的方式愉快的插入图片了。</p><p>我们做了这么多都是为了方便，那么为什么不再方便一点呢。</p><h2 id="hexo与Typora的完美结合"><a href="#hexo与Typora的完美结合" class="headerlink" title="hexo与Typora的完美结合"></a><strong>hexo与Typora的完美结合</strong></h2><p>上述是从文章资源文件夹中引用图片，前提是<strong>先将图片放入到文章资源文件夹</strong>，如果图片数量众多的话，一张一张的放很影响效率。但是不用怕，我们有很方便的解决方法。</p><p><strong>Typora</strong>是我非常喜欢的Markdown文本编辑器，在之前的文章中也介绍过一点。</p><p>Typora对于插入图片的支持做得非常好，在<code>文件-&gt;偏好设置</code>或者直接<code>&lt;C-,&gt;</code>进入设置。</p><p><img src="/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/v2-52220b2dba6901ee2181b72951d25a7b_720w.webp" alt="img"></p><p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p><p>如复制网络路径的图片<code>https://...../image.jpg</code>粘贴到Typora中叫<code>文章名</code>的文章后，图片会自动变为<code>![](文章名/image.jpg)</code>。</p><p>但我们知道部署后，文件路径是不同的，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的<code>文件名/</code>。不慌，也很简单。</p><p>在Typora编辑器中，使用<code>&lt;C-f&gt;</code>快捷键，将所有的<code>文章名/</code>替换为空即可删除。</p><p><img src="/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/v2-9202796d27f4659d96ff13b11e6808c1_720w.png" alt="img"></p><p>然后再将博客上传，图片就会随着文章一起打包。在网页中就可以看到正常显示的图片，大功告成。</p><p>————-本地预览不显示图片的问题—————-</p><p>在typora的设置中选择图片工具，为文章设置一个图片根目录。设置方式如下，之后选中存放图片的目录即可，根据不同版本的typora该设置项可以能在不能的位置。</p><p><img src="/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/v2-8d28ac51aedad913907c45b4907d325f_720w.webp" alt="img"></p><p>格式 -&gt; 图片工具 -&gt; 设置图片根目录</p><h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p>1.<a href="https://zhuanlan.zhihu.com/p/370635512">超详细 Hexo + Github Pages 博客搭建教程 - 知乎 (zhihu.com)</a></p><p>2.<a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册 (fluid-dev.com)</a></p><p>3.<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid: :ocean: 一款 Material Design 风格的 Hexo 主题 &#x2F; An elegant Material-Design theme for Hexo (github.com)</a></p><p>4.<a href="https://hexo.io/zh-cn/index.html">Hexo</a></p><p>5.<a href="https://github.com/fluid-dev/hexo-theme-fluid/issues/961">Error: Cannot find module ‘css’ · Issue #961 · fluid-dev&#x2F;hexo-theme-fluid (github.com)</a></p><p>6.<a href="https://zhuanlan.zhihu.com/p/265077468">hexo博客如何插入图片 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/06/23/hello-world/"/>
    <url>/2023/06/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
