<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2023/09/02/redis/"/>
    <url>/2023/09/02/redis/</url>
    
    <content type="html"><![CDATA[<h2 id="1-NoSql数据库简介"><a href="#1-NoSql数据库简介" class="headerlink" title="1 NoSql数据库简介"></a>1 NoSql数据库简介</h2><h3 id="1-1-nosql数据库的引入"><a href="#1-1-nosql数据库的引入" class="headerlink" title="1.1 nosql数据库的引入"></a>1.1 nosql数据库的引入</h3><h4 id="1-1-1-技术的分类"><a href="#1-1-1-技术的分类" class="headerlink" title="1.1.1 技术的分类"></a>1.1.1 技术的分类</h4><p>目前我们学过很多技术，比如：</p><p>1、解决功能性的问题：JavaSE、Jsp、servlet、Tomcat、HTML、Linux、JDBC、SVN</p><p>2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</p><p>3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p><p>我们开发一个项目，无论这个项目的业务多么复杂，无外乎就是增删改查的操作。而这些功能我们要实现，通过<strong>解决功能性的问题的技术栈</strong>就可以轻松实现。但是项目的功能不可能一成不变，项目功能会随着需求的变化不而不断的增加、修改和升级。这个时候我们就需要对项目的功能进行扩展和增强，但是对项目进行扩展和增强我们需要不影响原有代码的前提下进行，此时我们可以使用<strong>解决扩展性的问题的技术栈(框架)</strong>进行操作。为什么框架能够解决程序的扩展性问题呢?因为框架定义了一定的约束和规范，我们只需要按照这些约束和规范进行开发就可以解决项目的扩展性问题。</p><p>现在我们再思考一个问题，项目开发完成之后，受众用户可能会有很多。随着用户量的不断增加，此时我们需要解决项目的性能问题。今天我们学习的nosql技术就是为了解决项目性能问题的。当然解决项目性能问题的技术栈还有很多，比如多线程技术、Nginx、MQ、ElasticSearch等。</p><h4 id="1-1-2-web的发展过程"><a href="#1-1-2-web的发展过程" class="headerlink" title="1.1.2 web的发展过程"></a>1.1.2 web的发展过程</h4><ul><li>Web1.0时代</li></ul><p>在Web1.0的时代，由于数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。</p><p><img src="20221001144631.png" style="zoom:80%"></p><ul><li>Web2.0时代</li></ul><p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p><p><img src="20221001144936.png" style="zoom:80%"></p><p>我们需要解决两个问题，第一个是CPU及内存的压力，第二个是IO压力。</p><ul><li>CPU及内存的压力</li></ul><p>由于一台web服务器不能应对海量用户的访问。我们可以考虑对web服务器进行冗余部署，可以根据用户的访问量部署多台。再通过Nginx对用户的访问进行负载均衡操作，将用户的访问压力分摊在不同的web服务器上。</p><p><img src="20221001145625.png" style="zoom:80%"></p><p>这样操作又会遇到一个问题，就是session问题。解决session的方案也有很多。</p><p>方案1：比如我们可以把session里面的数据存放在cookie端，以后用户每次发送请求，都可以携带cookie里面的数据到服务器。但由于cookie存放在浏览器端，如果数据是敏感数据，存放在cookie会不安全。</p><p>方案2：session复制。将某台服务器里面的session复制一份到其他服务器里面去。这种方案也有缺点，就是把相同的session数据存放在不同的web服务器中，容易造成数据冗余，服务器空间的浪费。</p><p>方案3：设置缓存数据库，将session信息存放在缓存数据库里面，缓存数据库里面的数据被所有web服务器共享。并且缓存数据库中的数据存放在内存中，读写速度也非常快。</p><p><img src="20221001150748.png" style="zoom:80%"></p><ul><li>IO压力</li></ul><p>随着项目数据的日积月累，数据库里面的数据也越来越庞大。加上用户访问量的增大，我们直接访问数据库获取数据会对数据库造成非常大的IO压力。如何解决?</p><p>方案1：考虑对数据库进行读写分离，水平拆分、垂直拆分。但是这种方式会破坏一定的业务规则。</p><p>方案2：将频繁查询的数据，放在缓存，以后我们只需要从缓存里获取数据即可，减少对数据库的访问压力。</p><p><img src="20221001151443.png" style="zoom:80%"></p><h3 id="1-2-nosql数据库的基本概述"><a href="#1-2-nosql数据库的基本概述" class="headerlink" title="1.2 nosql数据库的基本概述"></a>1.2 nosql数据库的基本概述</h3><h4 id="1-2-1-什么是nosql数据库"><a href="#1-2-1-什么是nosql数据库" class="headerlink" title="1.2.1 什么是nosql数据库"></a>1.2.1 什么是nosql数据库</h4><p>NoSQL(NoSQL = <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。 NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。nosql数据库有以下特点：</p><ul><li>不遵循SQL标准。</li><li>不支持ACID。</li><li>远超于SQL的性能。</li></ul><p>那么nosql有哪些适用场景呢?</p><ul><li>对数据高并发的读写</li><li>海量数据的读写</li><li>对数据高可扩展性的</li></ul><p>当然nosql也有不适用的场景:</p><ul><li>需要事务支持</li><li>基于sql的结构化查询存储，处理复杂的关系,需要sql查询。</li></ul><h4 id="1-2-2-常见的nosql数据库"><a href="#1-2-2-常见的nosql数据库" class="headerlink" title="1.2.2 常见的nosql数据库"></a>1.2.2 常见的nosql数据库</h4><ul><li>Memcache</li></ul><p>Memcache很早出现的NoSql数据库， 数据都在内存中，<font color="red">一般不持久化。</font>支持简单的key-value模式，支持类型单一。一般是作为缓存数据库辅助持久化的数据库</p><ul><li><strong>redis</strong></li></ul><p>redis几乎覆盖了Memcached的绝大部分功能,数据都在内存中，<font color="red">支持持久化，</font>主要用作备份恢复。 除了支持简单的key-value模式，还支持<font color="red">多种数据结构</font>的存储，比如 list、set、hash、zset等。一般是作为缓存数据库辅助持久化的数据库。</p><ul><li>MongoDB</li></ul><p>MongoDB 高性能、开源、模式自由(schema free)的<strong>文档型数据库(类似于json)</strong>。数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘。虽然是key-value模式，但是对value（尤其是<strong>json</strong>）提供了丰富的查询功能。MongoDB支持二进制数据及大型对象。</p><p>我们通过<a href="https://db-engines.com/en/ranking。查看最新的数据库排名">https://db-engines.com/en/ranking。查看最新的数据库排名</a>:</p><p><img src="image-20230902075408640.png" alt="image-20230902075408640"></p><h4 id="1-2-3-redis的诞生历史"><a href="#1-2-3-redis的诞生历史" class="headerlink" title="1.2.3 redis的诞生历史"></a>1.2.3 redis的诞生历史</h4><p>08年的时候有一个意大利西西里岛的小伙子，笔名antirez (htp:/linvece.org!)，创建了一个访客信息网站LLOOGG.COM。有的时候我们需要知道网站的访问情况，比如访客的IP、操作系统、浏览器、使用的搜索关键词、所在地区、访问的网页地址等等。在国内，有很多网站提供了这个功能，比如CNZZ，百度统计，国外也有谷歌的GoogleAnalytics。我们不用自己写代码去实现这个功能，只需要在全局的footer里面嵌入一段JS代码就行了，当页面被访问的时候，就会自动把访客的信息发送到这些网站统计的服务器，然后我们登录后台就可以查看数据了。<br>LLOOGG.COM提供的就是这种功能，它可以查看最多10000条的最新浏览记录。<br>这样的话，它需要为每一个网站创建一个列表(List)，不同网站的访问记录进入到不同的列表。如果列表的长度超过了用户指定的长度，它需要把最早的记录删除(先进先出)。<br>当LLOOGG.COM的用户越来越多的时候，它需要维护的列表数量也越来越多，这种记录最新的请求和删除最早的请求的操作也越来越多。LLOOGG.COM最初使用的数据库是MySQL，可想而知，因为每一次记录和删除都要读写磁盘，因为数据量和并发量太大，在这种情况下无论怎么去优化数据库都不管用了。<br>考虑到最终限制数据库性能的瓶颈在于磁盘，所以antirez打算放弃磁盘，自己去实现一个具有列表结构的数据库的原型，把数据放在内存而不是磁盘，这样可以大大地提升列表的push和pop的效率。antrez发现这种思路确实能解决这个问题，所以用C语言重写了这个内存数据库，并且加上了持久化的功能，09年，Redis横空出世了。从最开始只支持列表的数据库，到现在支持多种数据类型，并且提供了一系列的高级特性，Redis已经成为一个在全世界被广泛使用的开源项目。<br>为什么叫REDIS呢?它的全称是REmote Dlctionary Service，直接翻译过来是远程字典服务。</p><h2 id="2-redis的概述和安装"><a href="#2-redis的概述和安装" class="headerlink" title="2 redis的概述和安装"></a>2 redis的概述和安装</h2><h3 id="2-1-redis的概述"><a href="#2-1-redis的概述" class="headerlink" title="2.1 redis的概述"></a>2.1 redis的概述</h3><ul><li><p>Redis是一个开源的key-value存储系统。</p></li><li><p>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hash（哈希类型）。</p></li><li><p>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p></li><li><p>在此基础上，Redis支持各种不同方式的排序。</p></li><li><p>与memcached一样，为了保证效率，数据都是缓存在内存中。</p></li><li><p>区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p></li><li><p>并且在此基础上实现了master-slave(主从)同步。</p></li></ul><p>基于这些特性，redis的使用场景非常广泛：</p><div class="table-container"><table><thead><tr><th>场景</th><th>解决方案</th></tr></thead><tbody><tr><td>获取最新数据</td><td>通过List实现按自然时间排序的数据</td></tr><tr><td>排行榜</td><td>利用Zset有序集合</td></tr><tr><td>时效性的数据，比如手机验证码</td><td>Expire过期</td></tr><tr><td>计数器、秒杀</td><td>原子性 自增方法INCR  DECR</td></tr><tr><td>去除大量数据中的重复数据</td><td>利用Set集合</td></tr><tr><td>构建队列</td><td>List集合</td></tr><tr><td>发布订阅消息系统</td><td>pub/sub模式</td></tr></tbody></table></div><h3 id="2-2-redis的安装"><a href="#2-2-redis的安装" class="headerlink" title="2.2 redis的安装"></a>2.2 redis的安装</h3><p>我们可以在官网上下载redis。redis的官网:<a href="https://redis.io。">https://redis.io。</a></p><p><img src="image-20230902080337054.png" alt="image-20230902080337054"></p><p>我的百度云了redis的安装包，大家可以在百度云里面自行下载：：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">链接：https://pan.baidu.com/s/1AXUsqV4js6Nw4ARObZDmqA <br>提取码：mj6a<br></code></pre></td></tr></table></figure><p>里面分别是linux版本，windows版本和压缩包版本</p><p><img src="image-20230902080608947.png" alt="image-20230902080608947"></p><h4 id="2-2-1-前期准备"><a href="#2-2-1-前期准备" class="headerlink" title="2.2.1 前期准备"></a>2.2.1 前期准备</h4><ul><li><p><strong>linux操作系统：</strong></p><ul><li><p>redis安装包：redis-6.2.1.tar.gz。</p></li><li><p>gcc编译器</p></li></ul></li><li><p><strong>windows操作系统：</strong></p><ul><li>redis安装包：Redis-x64-3.0.504.msi</li></ul></li></ul><h4 id="2-2-2-安装步骤"><a href="#2-2-2-安装步骤" class="headerlink" title="2.2.2 安装步骤"></a>2.2.2 安装步骤</h4><h5 id="linux操作系统："><a href="#linux操作系统：" class="headerlink" title="linux操作系统："></a><strong>linux操作系统：</strong></h5><ul><li>下载安装最新版的gcc编译器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine opt]~$ gcc --version  # 通过查看gcc版本，查看本机linux系统里面是否安装gcc工具<br>bash: gcc: 未找到命令...<br>[qgc@qgc-virtual-machine opt]~$ yum install gcc  # 安装gcc编译工具<br>[qgc@qgc-virtual-machine opt]~$ gcc --version  # 安装完成之后 再次查看gcc编译工具版本<br>gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)<br>Copyright © 2015 Free Software Foundation, Inc.<br>本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；<br>包括没有适销性和某一专用目的下的适用性担保。<br></code></pre></td></tr></table></figure><ul><li>将redis安装包上传至/opt目录</li></ul><p>这一步就是想办法把你的redis安装包上传到linux上，有人用的ssh可视化工具，这个仁者见仁智者见智，我用的ssh的scp，步骤如下：</p><p>1）linux端用ifconfig命令查看网络,（inet 地址：<em> </em> <em> ………</em>就是我们要连接的ip）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$ ifconfig<br>ens32     Link encap:以太网  硬件地址 00:0c:29:7d:b7:71  <br>          inet 地址:192.168.84.128  广播:192.168.84.255  掩码:255.255.255.0<br>          inet6 地址: fe80::acf8:e9e:e906:e094/64 Scope:Link<br>          UP BROADCAST RUNNING MULTICAST  MTU:1500  跃点数:1<br>          接收数据包:28233 错误:0 丢弃:0 过载:0 帧数:0<br>          发送数据包:2651 错误:0 丢弃:0 过载:0 载波:0<br>          碰撞:0 发送队列长度:1000 <br>          接收字节:40665365 (40.6 MB)  发送字节:205420 (205.4 KB)<br><br>lo        Link encap:本地环回  <br>          inet 地址:127.0.0.1  掩码:255.0.0.0<br>          inet6 地址: ::1/128 Scope:Host<br>          UP LOOPBACK RUNNING  MTU:65536  跃点数:1<br>          接收数据包:369 错误:0 丢弃:0 过载:0 帧数:0<br>          发送数据包:369 错误:0 丢弃:0 过载:0 载波:0<br>          碰撞:0 发送队列长度:1000 <br>          接收字节:34193 (34.1 KB)  发送字节:34193 (34.1 KB)<br></code></pre></td></tr></table></figure><p>如上192.168.84.128就是我们要连接的ip</p><p>2）window端使用scp：</p><p>找到自己的redis安装包地址，如我的是：”C:\Users\Administrator\Desktop\‎\学习\个人学习\redis\redis软件\redis-6.2.1.tar.gz”</p><p>然后具体操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">PS C:\Windows\System32\WindowsPowerShell\v1.0&gt; 输入# scp &quot;C:\Users\Administrator\Desktop\‎\学习\个人学习\redis\redis软件\redis-6.2.1.tar.gz&quot; qgc@192.168.84.128:<br><br>输出：<br>qgc@192.168.84.128&#x27;s password:输入你的linux系统密码<br>redis-6.2.1.tar.gz                                                                    100% 2381KB  39.4MB/s   00:00<br></code></pre></td></tr></table></figure><p>至此安装包上传完毕。</p><ul><li><p>解压redis安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$ tar -zxvf redis-6.2.1.tar.gz<br>qgc@qgc-virtual-machine:~$ ll<br>总用量 2516<br>drwxrwxr-x  7 qgc  qgc     4096 3月   2  2021 redis-6.2.1/ # 解压之后的目录<br>-rw-rw-r--  1 qgc  qgc  2438367 9月   2 09:05 redis-6.2.1.tar.gz<br></code></pre></td></tr></table></figure></li></ul><p>  注意：<strong>如果没有准备好C语言编译环境，make 会报错—Jemalloc/jemalloc.h：没有那个文件</strong></p><p>  解决方案: 先准备好gcc环境，然后执行如下命令：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$  make distclean  # 清除执行编译的c文件<br>qgc@qgc-virtual-machine:~$  make  # 再次执行make操作<br></code></pre></td></tr></table></figure><ul><li><p>进入redis安装目录，执行make指令进行编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$ cd redis-6.2.1/<br>qgc@qgc-virtual-machine:~$ make<br></code></pre></td></tr></table></figure><p>完成后最后输出如图：</p><p><img src="image-20230902091421724.png" alt="image-20230902091421724"></p></li><li><p>编译之后，执行安装命令</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$ sudo make install<br>cd src &amp;&amp; make install<br>make[1]: 进入目录“/opt/redis-6.2.1/src”<br>    CC Makefile.dep<br>make[1]: 离开目录“/opt/redis-6.2.1/src”<br>make[1]: 进入目录“/opt/redis-6.2.1/src”<br><br>Hint: It&#x27;s a good idea to run &#x27;make test&#x27; ;)<br><br>    INSTALL install<br>    INSTALL install<br>    INSTALL install<br>make[1]: 离开目录“/opt/redis-6.2.1/src”<br></code></pre></td></tr></table></figure><p>注意：<strong>安装成功之后，默认的安装目录是/usr/local/bin</strong>。我们可以去查看具体的安装详情：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$ cd /usr/local/bin<br>qgc@qgc-virtual-machine:~$ ll<br>总用量 14336<br>drwxr-xr-x  2 root root    4096 9月   2 09:16 ./<br>drwxr-xr-x 10 root root    4096 2月  27  2019 ../<br>-rwxr-xr-x  1 root root 3553580 9月   2 09:16 redis-benchmark*<br>lrwxrwxrwx  1 root root      12 9月   2 09:16 redis-check-aof -&gt; redis-server*<br>lrwxrwxrwx  1 root root      12 9月   2 09:16 redis-check-rdb -&gt; redis-server*<br>-rwxr-xr-x  1 root root 3747576 9月   2 09:16 redis-cli*<br>lrwxrwxrwx  1 root root      12 9月   2 09:16 redis-sentinel -&gt; redis-server*<br>-rwxr-xr-x  1 root root 7367928 9月   2 09:16 redis-server*<br></code></pre></td></tr></table></figure><p>这里我们简单了解这几个文件的用途：</p><ul><li>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</li><li>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</li><li>redis-check-dump：修复有问题的dump.rdb文件</li><li>redis-sentinel：Redis集群使用</li><li>redis-server：Redis服务器启动命令</li><li>redis-cli：客户端，操作入口</li></ul><h5 id="window安装"><a href="#window安装" class="headerlink" title="window安装"></a>window安装</h5><p>直接双击Redis-x64-3.0.504.msi文件，然后一直下一步就可以啦！！！</p><h3 id="2-3-redis启动"><a href="#2-3-redis启动" class="headerlink" title="2.3 redis启动"></a>2.3 redis启动</h3><h4 id="2-3-1-redis前台启动-不推荐"><a href="#2-3-1-redis前台启动-不推荐" class="headerlink" title="2.3.1 redis前台启动(不推荐)"></a>2.3.1 redis前台启动(不推荐)</h4><p>前台启动，命令行窗口不能关闭，否则服务器停止。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$ redis-server<br></code></pre></td></tr></table></figure><p><img src="image-20230902092140721.png" alt="image-20230902092140721"></p><h4 id="2-3-2-redis后台启动-推荐"><a href="#2-3-2-redis后台启动-推荐" class="headerlink" title="2.3.2 redis后台启动(推荐)"></a>2.3.2 redis后台启动(推荐)</h4><ul><li>进入redis的解压目录，拷贝一份redis.conf配置文件到redis安装目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$ cd redis-6.2.1/<br>qgc@qgc-virtual-machine:~$ sudo cp redis.conf /usr/local/bin<br>qgc@qgc-virtual-machine:~$ cd /usr/local/bin<br>qgc@qgc-virtual-machine:~$ ll<br></code></pre></td></tr></table></figure><p><img src="image-20230902092947240.png" alt="image-20230902092947240"></p><ul><li>编辑redis.conf配置文件，<strong>后台启动设置daemonize no改成yes</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$ vim redis.conf<br></code></pre></td></tr></table></figure><ul><li>启动redis</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$ redis-server redis.conf <br>qgc@qgc-virtual-machine:~$ ps -ef | grep redis  # 查看redis的服务进程<br>qgc       9130  1016  0 09:18 ?        00:00:02 redis-server *:6379<br>qgc       9919  9208  0 09:43 pts/18   00:00:00 grep --color=auto redis<br></code></pre></td></tr></table></figure><ul><li>使用客户端连接redis</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$ redis-cli # 使用redis自带客户端连接redis<br>127.0.0.1:6379&gt; ping  # 查看是否ping通redis服务器<br>PONG<br></code></pre></td></tr></table></figure><ul><li>关闭redis服务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$ redis-cli shutdown  # 关闭redis服务<br>qgc@qgc-virtual-machine:~$ ps -ef | grep redis<br>qgc      10160  9208  0 10:05 pts/18   00:00:00 grep --color=auto redis<br></code></pre></td></tr></table></figure><p>关闭错误参考文档：</p><p><a href="https://blog.csdn.net/qq_46127735/article/details/113933690">Redis关闭服务错误——(error) ERR Errors trying to SHUTDOWN. Check logs._、以吾之名的博客-CSDN博客</a></p><p>如果reids是多实例，，也可以指定端口关闭：redis-cli -p 6379 shutdown</p><ul><li><p>开放redis端口号6379的远程访问权限</p><ul><li><p>修改配置文件注释掉如下内容</p><p><img src="image-20230902093817472.png" alt="image-20230902093817472"></p></li><li><p>关闭本地防护：</p><p>改前：</p></li></ul></li></ul><p><img src="image-20230902093907056.png" alt="image-20230902093907056"></p><p>​                改后：</p><p><img src="image-20230902094205787.png" alt="image-20230902094205787"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">qgc@qgc-virtual-machine:~$ firewall-cmd --permanent --add-port=6379/tcp<br>success<br>qgc@qgc-virtual-machine:~$ firewall-cmd --reload<br>success<br>qgc@qgc-virtual-machine:~$ firewall-cmd --list-ports<br>3306/tcp 8080/tcp 6379/tcp<br></code></pre></td></tr></table></figure><p>至于视图工具参考（我用的Navicat16）：</p><p><a href="https://www.cnblogs.com/ssmushui/p/17556189.html">Navicat最新162激活破解 - 山石木水 - 博客园 (cnblogs.com)</a></p><p>连接成功如图</p><p><img src="image-20230902110941189.png" alt="image-20230902110941189"></p><h3 id="2-4-redis的相关知识"><a href="#2-4-redis的相关知识" class="headerlink" title="2.4 redis的相关知识"></a>2.4 redis的相关知识</h3><ul><li>为什么redis的端口号是6379?</li></ul><p><img src="20221001193052.png" style="zoom:60%"></p><p>6379在是手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字。</p><p>Alessia Merz 是一位意大利舞女、女演员。 Redis 作者 Antirez 早年看电视节目，觉得 Merz 在节目中的一些话愚蠢可笑，Antirez 喜欢造“梗”用于平时和朋友们交流，于是造了一个词 “MERZ”，形容愚蠢，与 “stupid” 含义相同。MERZ长期以来被Redis作者antirez及其朋友当作愚蠢的代名词。</p><p>后来 Antirez 重新定义了 “MERZ” ，形容”具有很高的技术价值，包含技艺、耐心和劳动，但仍然保持简单本质“。</p><p>到了给 Redis 选择一个数字作为默认端口号时，Antirez 没有多想，把 “MERZ” 在手机键盘上对应的数字 6379 拿来用了。</p><ul><li>redis默认的数据库实例</li></ul><p>默认16个数据库，类似数组下标从0开始，初始默认使用0号库。使用命令 <code>select  &lt;dbid&gt;</code>来切换数据库。如: select 8 。dbsize查看当前数据库的key的数量。flushdb清空当前库。</p><ul><li>Redis是单线程+多路IO复用技术</li></ul><p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p><p><strong>memcached：串行  vs  多线程+锁</strong></p><p> <strong>redis: 单线程+多路IO复用(Redis)</strong></p><h2 id="3-redis常用数据类型操作"><a href="#3-redis常用数据类型操作" class="headerlink" title="3 redis常用数据类型操作"></a>3 redis常用数据类型操作</h2><h3 id="3-1-redis基于key-键-的操作"><a href="#3-1-redis基于key-键-的操作" class="headerlink" title="3.1 redis基于key(键)的操作"></a>3.1 redis基于key(键)的操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; keys *   # 查看当前数据库中所有的key值<br>(empty array)<br>127.0.0.1:6379&gt; set k1 eric  # 设置key值 值是string类型<br>OK<br>127.0.0.1:6379&gt; set k2 james<br>OK<br>127.0.0.1:6379&gt; set k3 kobe<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) &quot;k1&quot;<br>2) &quot;k3&quot;<br>3) &quot;k2&quot;<br>127.0.0.1:6379&gt; type k2  # 查看指定key的数据类型<br>string <br>127.0.0.1:6379&gt; exists k1  # 判断指定的key是否存在  存在就为1 不存在就为0<br>(integer) 1<br>127.0.0.1:6379&gt; exists k4<br>(integer) 0<br>127.0.0.1:6379&gt; del key k3  # 删除指定的key值<br>(integer) 1<br>127.0.0.1:6379&gt; keys *<br>1) &quot;k1&quot;<br>2) &quot;k2&quot;<br>127.0.0.1:6379&gt; expire k1 10  # 给key设置过期时间<br>(integer) 1<br>127.0.0.1:6379&gt; ttl k1  # 查看指定key值的存活时期 不存在就为负数<br>(integer) 6<br>127.0.0.1:6379&gt; ttl k1<br>(integer) -2<br>127.0.0.1:6379&gt; select 0  # 切换到指定的数据库<br>OK<br>127.0.0.1:6379&gt; dbsize  # 查看当前数据库的key的数量<br>(integer) 1<br>127.0.0.1:6379&gt; flushdb  # 清空当前数据库<br>OK<br>127.0.0.1:6379&gt; flushall  # 清空所有的数据库<br>OK<br></code></pre></td></tr></table></figure><h3 id="3-2-redis中string的操作"><a href="#3-2-redis中string的操作" class="headerlink" title="3.2 redis中string的操作"></a>3.2 redis中string的操作</h3><h4 id="3-2-1-redis中string的介绍"><a href="#3-2-1-redis中string的介绍" class="headerlink" title="3.2.1 redis中string的介绍"></a>3.2.1 redis中string的介绍</h4><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M。</p><h4 id="3-2-2-redis中string的常用命令"><a href="#3-2-2-redis中string的常用命令" class="headerlink" title="3.2.2 redis中string的常用命令"></a>3.2.2 redis中string的常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; keys *<br>(empty array)<br>127.0.0.1:6379&gt; set k1 eric  # 给key设置String类型的值<br>OK<br>127.0.0.1:6379&gt; set k2 kobe<br>OK<br>127.0.0.1:6379&gt; get k1  # 根据key获取对象的value值<br>&quot;eric&quot;<br>127.0.0.1:6379&gt; get k2<br>&quot;kobe&quot;<br>127.0.0.1:6379&gt; set k1 james # 如果给一个已经存在的key设置值就是覆盖原来的值<br>OK<br>127.0.0.1:6379&gt; get k1<br>&quot;james&quot;<br>127.0.0.1:6379&gt; append k1 123 # 在指定key的值后面追加内容<br>(integer) 8  # 追加之后字符串的长度<br>127.0.0.1:6379&gt; get k1<br>&quot;james123&quot;<br>127.0.0.1:6379&gt; strlen k1  # 获取key的长度<br>(integer) 8<br>127.0.0.1:6379&gt; setnx k1 miller # 当可以不存在时 value才会设置成功，否则设置不成功<br>(integer) 0  # 0 标识没有设置成功<br>127.0.0.1:6379&gt; get k1  # k1的值没有发生变化，因为key已经存在<br>&quot;james123&quot;<br>127.0.0.1:6379&gt; setnx k3 curry  # k3的值设置成功，因为之前不存在key3这个键<br>(integer) 1   # 1 标识设置成功<br>127.0.0.1:6379&gt; get k3<br>&quot;curry&quot;<br>127.0.0.1:6379&gt; set num1 100  <br>OK<br>127.0.0.1:6379&gt; incr num1 # incr命令操作的值必须是数字类型  incr:对key自增1<br>(integer) 101<br>127.0.0.1:6379&gt; get num1<br>&quot;101&quot;<br>127.0.0.1:6379&gt; decr num1 # 对key进行自减操作<br>(integer) 100<br>127.0.0.1:6379&gt; get num1<br>&quot;100&quot;<br>127.0.0.1:6379&gt; incrby num1 5  # 对key进行增加 指定增加5<br>(integer) 105<br>127.0.0.1:6379&gt; decrby num1 10  # 对key进行递减 指定减去5<br>(integer) 95<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><p><strong>incr命令是原子操作。</strong>也就是指不会被线程调度机制打断的操作。这种操作一旦开始，就一直运行到结束，中间不会有任何线程上下文切换。在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”。</p><p><strong>问题：</strong></p><p><strong>Java中的i++属于原子性操作吗?  不是</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">i++; 不是原子操作<br>第一步：取值  i = 0;<br>第二步：自加操作 i++;<br>第三步：将自加的操作结果赋予给i。<br></code></pre></td></tr></table></figure><p><strong>i = 0，两个线程对i分别进行i++100次。值是多少?(2-200)</strong></p><p>首先在两个线程互不干扰的情况下，分别对i++执行，一个线程执行完再执行另一个线程，这样就会使i自增200次，即最终为200，这是理想状态下的互不干涉，最坏情况则为，第一个线程执行了99次，当A线程的i++执行到99次时，此时cpu1寄存器中值为99，内存为99</p><p>当B线程cpu2寄存器的1，写回内存覆盖内存的99，变成1</p><p>如果可以这样，那A线程也可以同样再覆盖一次B线程，最终结果就是2。</p><p>redis操作string的其他命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3  # 批量设置k-v<br>OK<br>127.0.0.1:6379&gt; mget k1 k2 k3 # 批量获取值<br>1) &quot;v1&quot;<br>2) &quot;v2&quot;<br>3) &quot;v3&quot;<br>127.0.0.1:6379&gt; msetnx k1 v11 k5 v5  # 只有所有的key都不存在，才会设置，任意一个key存在，都不会设置值<br>(integer) 0<br>127.0.0.1:6379&gt; msetnx k4 v4 k5 v5<br>(integer) 1<br>127.0.0.1:6379&gt; mget k4 k5<br>1) &quot;v4&quot;<br>2) &quot;v5&quot;<br>127.0.0.1:6379&gt; set name LebronJames<br>OK<br>127.0.0.1:6379&gt; getrange name 0 6  #根据指定区间获取字符串的值 索引值从0开始<br>&quot;LebronJ&quot;<br>127.0.0.1:6379&gt; getrange name 0 5<br>&quot;Lebron&quot;<br>127.0.0.1:6379&gt; setrange name 0 kobe  # 从指定索引值开始替换值<br>(integer) 11<br>127.0.0.1:6379&gt; get name<br>&quot;kobeonJames&quot;<br>127.0.0.1:6379&gt; setex k6 20 v6  # 设置key的值的同时，也设置过期时间<br>OK<br>127.0.0.1:6379&gt; ttl k6<br>(integer) 16<br>127.0.0.1:6379&gt; get name<br>&quot;kobeonJames&quot;<br>127.0.0.1:6379&gt; getset name green  # 使用新值替换旧值，但是返回旧值 <br>&quot;kobeonJames&quot;<br>127.0.0.1:6379&gt; get name<br>&quot;green&quot;<br></code></pre></td></tr></table></figure><h3 id="3-3-redis中list的操作"><a href="#3-3-redis中list的操作" class="headerlink" title="3.3 redis中list的操作"></a>3.3 redis中list的操作</h3><p>List列表是单键多值的列表。Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际是个双向链表，对两端的操作性能很高，但是通过索引下标操作中间的节点性能会较差。</p><p><img src="20221003123923.png" style="zoom:80%"></p><h4 id="3-3-1-list的常用命令"><a href="#3-3-1-list的常用命令" class="headerlink" title="3.3.1 list的常用命令"></a>3.3.1 list的常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; lpush k1 v1 v2 v3  # 从列表的左边追加元素 键是k1 值是v1 v2 v3<br>(integer) 3<br>127.0.0.1:6379&gt; lrange k1 0 -1  # 查询列表中的所有元素<br>1) &quot;v3&quot;<br>2) &quot;v2&quot;<br>3) &quot;v1&quot;<br>127.0.0.1:6379&gt; rpush k1 v4 v5 v6  # 从列表的右边追加元素 键是k1 值是v4 v5 v6<br>(integer) 6<br>127.0.0.1:6379&gt; lrange k1 0 -1<br>1) &quot;v3&quot;<br>2) &quot;v2&quot;<br>3) &quot;v1&quot;<br>4) &quot;v4&quot;<br>5) &quot;v5&quot;<br>6) &quot;v6&quot;<br>127.0.0.1:6379&gt; lpop k1  # 从左边弹出一个值并返回<br>&quot;v3&quot;<br>127.0.0.1:6379&gt; rpop k1  # 从右边弹出一个值并返回<br>&quot;v6&quot;<br>127.0.0.1:6379&gt; lpush k2 s1 s2 s3   # 创建k2列表 并追加值<br>(integer) 3<br>127.0.0.1:6379&gt; lrange k2 0 -1<br>1) &quot;s3&quot;<br>2) &quot;s2&quot;<br>3) &quot;s1&quot;<br>127.0.0.1:6379&gt; lrange k1 0 -1<br>1) &quot;v2&quot;<br>2) &quot;v1&quot;<br>3) &quot;v4&quot;<br>4) &quot;v5&quot;<br>127.0.0.1:6379&gt; rpoplpush k1 k2 # 将k1列表最右边的值取出来,追加到k2列表的最左边<br>&quot;v5&quot;<br>127.0.0.1:6379&gt; lrange k1 0 -1  # k1最右边的元素没有了<br>1) &quot;v2&quot;<br>2) &quot;v1&quot;<br>3) &quot;v4&quot;<br>127.0.0.1:6379&gt; lrange k2 0 -1  # 查看k2集合 k2元素的最左边追加了元素v5<br>1) &quot;v5&quot;<br>2) &quot;s3&quot;<br>3) &quot;s2&quot;<br>4) &quot;s1&quot;<br>127.0.0.1:6379&gt; lindex k2 2  # 根据指定下标获取元素<br>&quot;s2&quot;<br>127.0.0.1:6379&gt; llen k2  # 获取指定列表的长度<br>(integer) 4<br>127.0.0.1:6379&gt; linsert k2 before s2  v2  # 在k2列表中的s2元素前面追加元素v2<br>(integer) 5<br>127.0.0.1:6379&gt; lrange k2 0 -1<br>1) &quot;v5&quot;<br>2) &quot;s3&quot;<br>3) &quot;v2&quot;<br>4) &quot;s2&quot;<br>5) &quot;s1&quot;<br>127.0.0.1:6379&gt; lrem k2 1 s2  # 从左边删除指定个数的元素s2<br>(integer) 1<br>127.0.0.1:6379&gt; lrange k2 0 -1<br>1) &quot;v5&quot;<br>2) &quot;s3&quot;<br>3) &quot;v2&quot;<br>4) &quot;s1&quot;<br>127.0.0.1:6379&gt; lset k2 2 s2  # 将指定索引位置上的元素替换(将k2列表中2号索引位置上的元素替换成s2)<br>OK<br>127.0.0.1:6379&gt; lrange k2 0 -1<br>1) &quot;v5&quot;<br>2) &quot;s3&quot;<br>3) &quot;s2&quot;<br>4) &quot;s1&quot;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-list的数据结构"><a href="#3-3-2-list的数据结构" class="headerlink" title="3.3.2 list的数据结构"></a>3.3.2 list的数据结构</h4><p>List的数据结构为快速链表quickList。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p><p>当数据量比较多的时候才会改成quicklist。</p><p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p><p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><p><img src="20221003132028.png" style="zoom:80%"></p><h3 id="3-4-redis中的set操作"><a href="#3-4-redis中的set操作" class="headerlink" title="3.4 redis中的set操作"></a>3.4 redis中的set操作</h3><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动去重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的命令，这个也是list所不能提供的。</p><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的<strong>复杂度都是</strong> <strong>O(1)</strong>。(随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变)</p><h4 id="3-4-1-set的常用命令"><a href="#3-4-1-set的常用命令" class="headerlink" title="3.4.1 set的常用命令"></a>3.4.1 set的常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; sadd s1 v1 v2 v3  # 向s1中添加元素 v1 v2 v3<br>(integer) 3<br>127.0.0.1:6379&gt; smembers s1  # 查询列表中的所有元素<br>1) &quot;v2&quot;<br>2) &quot;v3&quot;<br>3) &quot;v1&quot;<br>127.0.0.1:6379&gt; sadd s1 v3  # 添加重复元素 没有添加成功<br>(integer) 0<br>127.0.0.1:6379&gt; smembers s1<br>1) &quot;v2&quot;<br>2) &quot;v3&quot;<br>3) &quot;v1&quot;<br>127.0.0.1:6379&gt; sismember s1 v1 # 判断集合是否存在某个元素 存在返回1 不存在返回0<br>(integer) 1<br>127.0.0.1:6379&gt; sismember s1 v7<br>(integer) 0<br>127.0.0.1:6379&gt; scard s1  # 返回集合中元素的个数<br>(integer) 3<br>127.0.0.1:6379&gt; srem s1 v1 v2  # 删除集合中指定的元素<br>(integer) 2<br>127.0.0.1:6379&gt; smembers s1<br>1) &quot;v3&quot;<br>127.0.0.1:6379&gt; spop s1  # 随机弹出集合中的某个元素<br>&quot;v4&quot;<br>127.0.0.1:6379&gt; smembers s1<br>1) &quot;v2&quot;<br>2) &quot;v3&quot;<br>3) &quot;v5&quot;<br>127.0.0.1:6379&gt; srandmember s1 2  # 随机弹出指定个数的元素,但是不会从集合中删除<br>1) &quot;v2&quot;<br>2) &quot;v3&quot;<br>127.0.0.1:6379&gt; smembers s1<br>1) &quot;v2&quot;<br>2) &quot;v3&quot;<br>3) &quot;v5&quot;<br>127.0.0.1:6379&gt; smove s1 s2 v5  # 将s1集合中的元素s5移动到s2集合中去。<br>(integer) 1<br>127.0.0.1:6379&gt; smembers s1<br>1) &quot;v3&quot;<br>127.0.0.1:6379&gt; smembers s2<br>1) &quot;v2&quot;<br>2) &quot;v3&quot;<br>3) &quot;v5&quot;<br>4) &quot;v1&quot;<br>127.0.0.1:6379&gt; sinter s1 s2  # 取集合s1 s2的交集<br>1) &quot;v3&quot;<br>127.0.0.1:6379&gt; sunion s1 s2 # 取集合s1 s2的并集<br>1) &quot;v2&quot;<br>2) &quot;v3&quot;<br>3) &quot;v5&quot;<br>4) &quot;v1&quot;<br>127.0.0.1:6379&gt; sdiff s2 s1  # 取s2的补集<br>1) &quot;v2&quot;<br>2) &quot;v5&quot;<br>3) &quot;v1&quot;<br></code></pre></td></tr></table></figure><h4 id="3-4-2-set的数据结构"><a href="#3-4-2-set的数据结构" class="headerlink" title="3.4.2 set的数据结构"></a>3.4.2 set的数据结构</h4><p>Set数据结构是dict字典，字典是用哈希表实现的。</p><p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><h3 id="3-5-redis中的hash操作"><a href="#3-5-redis中的hash操作" class="headerlink" title="3.5 redis中的hash操作"></a>3.5 redis中的hash操作</h3><p>Redis hash 是一个键值对集合。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map<String,Object></p><p>需求：在redis里面保存一个用户对象( {id:1001,username:”eric”,age=23} )。</p><p><strong>方案1：</strong></p><p>将user对象转换成一个json字符串，使用string来存储这个json字符串。</p><p>缺点：每次修改这个对象里面的数据，都需要把这个字符串转换成java对象修改，修改之后再转换成json字符串，比较麻烦，不适合频繁修改数据的场景。</p><p><strong>方案2：</strong></p><p>通过key和对象属性拼接的方式存储数据:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">  key           value<br>user:id          1001<br>user:username    eric<br>user:age         23<br></code></pre></td></tr></table></figure><p>缺点：存储的数据分散，如果对象的属性过多，在redis中的key也会非常的多。</p><p><strong>方案3：</strong></p><p>通过redis中的hash类型的数据保存</p><p><img src="20221003145035.png"></p><p>优点：<strong>通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。</strong></p><h4 id="3-5-1-hash的常用命令"><a href="#3-5-1-hash的常用命令" class="headerlink" title="3.5.1 hash的常用命令"></a>3.5.1 hash的常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hset user id 1001  # 向hash中存储数据 key是user field是id 值是1001<br>(integer) 1<br>127.0.0.1:6379&gt; hget user id # 获取指定的数据<br>&quot;1001&quot;<br>127.0.0.1:6379&gt; hmset user username eric age 23 # 批量向hash集合中添加数据<br>OK<br>127.0.0.1:6379&gt; hmget user username age  # 批量向hash集合中获取数据<br>1) &quot;eric&quot;<br>2) &quot;23&quot;<br>127.0.0.1:6379&gt; hexists user username  # 判断key中是否存在指定的field 存在返回1  不存在返回0<br>(integer) 1<br>127.0.0.1:6379&gt; hkeys user  # 获取所有的field<br>1) &quot;id&quot;<br>2) &quot;username&quot;<br>3) &quot;age&quot;<br>127.0.0.1:6379&gt; hvals user  # 获取所有的value值<br>1) &quot;1001&quot;<br>2) &quot;eric&quot;<br>3) &quot;23&quot;<br>127.0.0.1:6379&gt; hdel user age  # 删除指定的field及其对应的值<br>(integer) 1<br>127.0.0.1:6379&gt; hget user age<br>(nil)<br>127.0.0.1:6379&gt; hincrby user id 1  # 对指定的field的值进行自增/自减操作  1 自增  -1 递减<br>(integer) 1002<br>127.0.0.1:6379&gt; hincrby user id -1<br>(integer) 1001<br>127.0.0.1:6379&gt; hsetnx user age 25  # 给对应的field设置值 如果field存在设置不成功，如果field不存在，则设置成功。<br>(integer) 1<br>127.0.0.1:6379&gt; hsetnx user username james<br>(integer) 0<br>127.0.0.1:6379&gt; hget user age<br>&quot;25&quot;<br>127.0.0.1:6379&gt; hget user username<br>&quot;eric&quot;<br></code></pre></td></tr></table></figure><h4 id="3-5-2-hash的数据结构"><a href="#3-5-2-hash的数据结构" class="headerlink" title="3.5.2 hash的数据结构"></a>3.5.2 hash的数据结构</h4><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><h3 id="3-6-redis中-的zset操作"><a href="#3-6-redis中-的zset操作" class="headerlink" title="3.6 redis中 的zset操作"></a>3.6 redis中 的zset操作</h3><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。<strong>集合的成员是唯一的，但是评分可以是重复了。</strong></p><p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h4 id="3-6-1-zset的常用命令"><a href="#3-6-1-zset的常用命令" class="headerlink" title="3.6.1 zset的常用命令"></a>3.6.1 zset的常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; zadd user 99 kobe 88 durant 82 curry  # 添加元素到zset集合中<br>(integer) 3<br>127.0.0.1:6379&gt; zrange user 0 -1 # 显示zset集合中的所有值(按照分数的升序排序)<br>1) &quot;curry&quot;<br>2) &quot;durant&quot;<br>3) &quot;kobe&quot;<br>127.0.0.1:6379&gt; zrange user 0 -1 withscores   # 显示zset集合中的所有值 包括元素对应的分数<br>1) &quot;curry&quot;<br>2) &quot;82&quot;<br>3) &quot;durant&quot;<br>4) &quot;88&quot;<br>5) &quot;kobe&quot;<br>6) &quot;99&quot;<br>127.0.0.1:6379&gt; zrangebyscore user 80 89  # 取指定区间的元素<br>1) &quot;curry&quot;<br>2) &quot;durant&quot;<br>127.0.0.1:6379&gt; zrangebyscore user 80 89 withscores   # 取指定区间的元素 包括元素对应的分数<br>1) &quot;curry&quot;<br>2) &quot;82&quot;<br>3) &quot;durant&quot;<br>4) &quot;88&quot;<br>127.0.0.1:6379&gt; zrevrangebyscore user 100 1 # 显示zset集合中的所有值(按照分数的降序排序)<br>1) &quot;kobe&quot;<br>2) &quot;durant&quot;<br>3) &quot;curry&quot;<br>127.0.0.1:6379&gt; zincrby user 12 kobe  # 给指定的元素增加分数<br>&quot;111&quot;<br>127.0.0.1:6379&gt; zrange user 0 -1 withscores<br>1) &quot;curry&quot;<br>2) &quot;82&quot;<br>3) &quot;durant&quot;<br>4) &quot;88&quot;<br>5) &quot;kobe&quot;<br>6) &quot;111&quot;<br>127.0.0.1:6379&gt; zrem user kobe  # 删除指定的元素<br>(integer) 1<br>127.0.0.1:6379&gt; zrange user 0 -1<br>1) &quot;curry&quot;<br>2) &quot;durant&quot;<br>127.0.0.1:6379&gt; zcount user 0 100  # 统计指定分数区间的元素个数<br>(integer) 2<br>127.0.0.1:6379&gt; zrange user 0 -1<br>1) &quot;curry&quot;<br>2) &quot;durant&quot;<br>127.0.0.1:6379&gt; zrank user durant  # 查询指定元素的排名<br>(integer) 1<br>127.0.0.1:6379&gt; zrank user curry<br>(integer) 0<br></code></pre></td></tr></table></figure><h4 id="3-6-2-zset的数据结构"><a href="#3-6-2-zset的数据结构" class="headerlink" title="3.6.2 zset的数据结构"></a>3.6.2 zset的数据结构</h4><p>zset底层使用了两个数据结构：</p><p>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p><p>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p><p>什么是跳跃表?</p><p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p><p>实例：</p><p>对比有序链表和跳跃表，从链表中查询出51。</p><ul><li>有序链表</li></ul><p><img src="20221003155230.png" style="zoom:80%"></p><p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p><ul><li>跳跃表</li></ul><p><img src="20221003155318.png" style="zoom:80%"></p><p>从第2层开始，1节点比51节点小，向后比较。</p><p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p><p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p><p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p><p><strong>从此可以看出跳跃表比有序链表效率要高。</strong></p><h2 id="4-redis配置文件的介绍"><a href="#4-redis配置文件的介绍" class="headerlink" title="4 redis配置文件的介绍"></a>4 redis配置文件的介绍</h2><h3 id="4-1-数据单位配置"><a href="#4-1-数据单位配置" class="headerlink" title="4.1 数据单位配置"></a>4.1 数据单位配置</h3><p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes。</p><p><img src="20221003163833.png" style="zoom:90%"></p><h3 id="4-2-INCLUDES配置"><a href="#4-2-INCLUDES配置" class="headerlink" title="4.2 INCLUDES配置"></a>4.2 INCLUDES配置</h3><p><img src="20221003164002.png" style="zoom:90%"></p><p>我们可以把一些配置信息定义在子配置文件里面，再在redis.conf中引入进来。</p><h3 id="4-3-网络相关的配置"><a href="#4-3-网络相关的配置" class="headerlink" title="4.3 网络相关的配置"></a>4.3 网络相关的配置</h3><h4 id="4-3-1-bind"><a href="#4-3-1-bind" class="headerlink" title="4.3.1 bind"></a>4.3.1 bind</h4><p>默认情况bind=127.0.0.1只能接受本机的访问请求。不写的情况下，无限制接受任何ip地址的访问。</p><p>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉。</p><p>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应。</p><p><img src="20221003164246.png" style="zoom:90%"></p><p>保存配置，停止服务，重启启动查看进程，不再是本机访问了。</p><p><img src="20221003164353.png" style="zoom:80%"></p><h4 id="4-3-2-protected-mode"><a href="#4-3-2-protected-mode" class="headerlink" title="4.3.2 protected-mode"></a>4.3.2 protected-mode</h4><p><img src="20221003164715.png" style="zoom:90%"></p><p>将本机访问保护模式设置no。这样其他机器就可以远程连接redis。</p><h4 id="4-3-3-port"><a href="#4-3-3-port" class="headerlink" title="4.3.3 port"></a>4.3.3 port</h4><p>redis的默认端口号：6379</p><p><img src="20221003164838.png" style="zoom:90%"></p><h4 id="4-3-4-tcp-backlog"><a href="#4-3-4-tcp-backlog" class="headerlink" title="4.3.4 tcp-backlog"></a>4.3.4 tcp-backlog</h4><p><img src="20221003164937.png" style="zoom:90%"></p><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。</p><p>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</p><p>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/netipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果。</p><h4 id="4-3-5-timeout"><a href="#4-3-5-timeout" class="headerlink" title="4.3.5 timeout"></a>4.3.5 timeout</h4><p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。</p><p><img src="20221003165202.png" style="zoom:90%"></p><h4 id="4-3-6-tcp-keepalive"><a href="#4-3-6-tcp-keepalive" class="headerlink" title="4.3.6 tcp-keepalive"></a>4.3.6 tcp-keepalive</h4><p>对访问客户端的一种心跳检测，每隔n秒检测一次。</p><p>单位为秒，如果设置为0，则不会进行Keepalive检测，默认值为300。</p><p><img src="20221003165420.png" style="zoom:90%"> </p><h3 id="4-4-GENERAL通用配置"><a href="#4-4-GENERAL通用配置" class="headerlink" title="4.4 GENERAL通用配置"></a>4.4 GENERAL通用配置</h3><h4 id="4-4-1-daemonize"><a href="#4-4-1-daemonize" class="headerlink" title="4.4.1 daemonize"></a>4.4.1 daemonize</h4><p>是否为后台进程，设置为yes，守护进程，后台启动。</p><p><img src="20221003165628.png" style="zoom:90%"></p><h4 id="4-4-2-pidfile"><a href="#4-4-2-pidfile" class="headerlink" title="4.4.2 pidfile"></a>4.4.2 pidfile</h4><p><img src="20221003165720.png" style="zoom:90%"></p><p>存放pid文件的位置，每个实例会产生一个不同的pid文件。</p><h4 id="4-4-3-loglevel"><a href="#4-4-3-loglevel" class="headerlink" title="4.4.3 loglevel"></a>4.4.3 loglevel</h4><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为<strong>notice</strong></p><p><img src="20221003165924.png" style="zoom:90%"></p><h4 id="4-4-4-logfile"><a href="#4-4-4-logfile" class="headerlink" title="4.4.4 logfile"></a>4.4.4 logfile</h4><p>日志文件的名称。</p><p><img src="20221003170120.png" style="zoom:90%"></p><h4 id="4-4-5-databases"><a href="#4-4-5-databases" class="headerlink" title="4.4.5 databases"></a>4.4.5 databases</h4><p>设定库的数量 默认16，默认数据库为0，可以使用<code>SELECT &lt;dbid&gt;</code>命令在连接上指定数据库id。</p><p><img src="20221003170244.png" style="zoom:90%"></p><h3 id="4-5-SECURITY安全配置"><a href="#4-5-SECURITY安全配置" class="headerlink" title="4.5 SECURITY安全配置"></a>4.5 SECURITY安全配置</h3><h4 id="4-5-1-设置密码"><a href="#4-5-1-设置密码" class="headerlink" title="4.5.1 设置密码"></a>4.5.1 设置密码</h4><p><img src="20221003175948.png" style="zoom:90%"></p><p>如果想要设置密码访问redis，需要进行如下配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; config get requirepass<br>1)&quot;requirepass&quot;<br>2)&quot;&quot;  # 密码默认为空<br>127.0.0.1:6379&gt; config set requirepass 123456<br>OK<br>127.0.0.1:6379&gt; auth 123456  # 一旦设置密码，所有的redis操作都要先验证密码<br>OK<br>127.0.0.1:6379&gt; get k1<br>&quot;v1&quot;<br></code></pre></td></tr></table></figure><h3 id="4-6-LIMITS配置"><a href="#4-6-LIMITS配置" class="headerlink" title="4.6 LIMITS配置"></a>4.6 LIMITS配置</h3><h4 id="4-6-1-maxclients"><a href="#4-6-1-maxclients" class="headerlink" title="4.6.1 maxclients"></a>4.6.1 maxclients</h4><p>maxclients：设置redis同时可以与多少个客户端进行连接。 默认情况下为10000个客户端。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p><p><img src="20221003171305.png" style="zoom:90%"></p><h4 id="4-6-2-maxmemory"><a href="#4-6-2-maxmemory" class="headerlink" title="4.6.2 maxmemory"></a>4.6.2 maxmemory</h4><p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机。</p><p>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p><p>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p><p>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p><p><img src="20221003171658.png" style="zoom:90%"></p><h4 id="4-6-3-maxmemory-policy"><a href="#4-6-3-maxmemory-policy" class="headerlink" title="4.6.3 maxmemory-policy"></a>4.6.3 maxmemory-policy</h4><ul><li>volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）</li><li>allkeys-lru：在所有集合key中，使用LRU算法移除key</li><li>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</li><li>allkeys-random：在所有集合key中，移除随机的key</li><li>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</li><li>noeviction：不进行移除。针对写操作，只是返回错误信息</li></ul><p><img src="20221003171842.png" style="zoom:90%"></p><h2 id="5-redis的发布和订阅"><a href="#5-redis的发布和订阅" class="headerlink" title="5 redis的发布和订阅"></a>5 redis的发布和订阅</h2><ul><li>打开一个客户端1订阅channel1</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[qgc@qgc-virtual-machine]~$ </span><span class="language-bash">redis-cli</span><br>127.0.0.1:6379&gt; subscribe channel1<br>Reading messages... (press Ctrl-C to quit)<br>1) &quot;subscribe&quot;<br>2) &quot;channel1&quot;<br>3) (integer) 1<br></code></pre></td></tr></table></figure><ul><li>打开客户端2，发送消息hello</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[qgc@qgc-virtual-machine]~$ </span><span class="language-bash">redis-cli</span><br>127.0.0.1:6379&gt; publish channel1 hello<br>(integer) 1<br></code></pre></td></tr></table></figure><ul><li>再次查看客户端1</li></ul><p><img src="image-20230902112849915.png" alt="image-20230902112849915"></p><h2 id="6-redis的新的数据类型"><a href="#6-redis的新的数据类型" class="headerlink" title="6 redis的新的数据类型"></a>6 redis的新的数据类型</h2><h3 id="6-1-Bitmap-位图"><a href="#6-1-Bitmap-位图" class="headerlink" title="6.1 Bitmap(位图)"></a>6.1 Bitmap(位图)</h3><p>现在我们来看一个场景，就是各大app都有签到的功能，大家可以思考，用户签到的功能是如何实现的。首先想到的就是设计一张签到表，将用户的签到信息持久化的保存在数据表里面。我们可以设计这么一张表：</p><p><img src="20221004134919.png" style="zoom:60%"></p><p>用户一次签到，就是一条记录,然后将记录持久化的保存在数据表里面。大家设想一下这么个场景：假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条。每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节。可以想象到1000万用户一年的数据量需要的内存空间该有多大。</p><p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p><p>我们可以采用类似这样的方案来实现我们的签到需求。</p><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p><img src="20221004141847.png" style="zoom:80%"></p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; setbit bit1 0 1  # 向指定的位置存入值<br>(integer) 0<br>127.0.0.1:6379&gt; setbit bit1 1 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit bit1 2 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit bit1 4 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit bit1 6 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit bit1 7 1<br>(integer) 0<br></code></pre></td></tr></table></figure><p>最后得到的结果是:</p><p><img src="20221004144534.png" style="zoom:80%"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; getbit bit1 1 # 从指定位置获取值<br>(integer) 1<br>127.0.0.1:6379&gt; getbit bit1 3<br>(integer) 0<br>127.0.0.1:6379&gt; bitcount bit1  # 统计1出现的次数(可以统计签到次数)<br>(integer) 6<br>127.0.0.1:6379&gt; bitfield bit1 get u2 0 #从0号索引开始获取2个bit位 再转换成10进制数据<br>1) (integer) 3<br>127.0.0.1:6379&gt; bitfield bit1 get u3 0<br>1) (integer) 7<br>127.0.0.1:6379&gt; bitpos bit1 0  # 统计第一个0出现的位置<br>(integer) 3<br>127.0.0.1:6379&gt; setbit unique:users:20201104 1 1  # 2020-11-04 日访问网站的userid=1,2,5,9。<br>(integer) 0<br>127.0.0.1:6379&gt; setbit unique:users:20201104 2 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit unique:users:20201104 5 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit unique:users:20201104 9 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit unique:users:20201103 0 1 # 2020-11-03 日访问网站的userid=0,1,4,9。<br>(integer) 0<br>127.0.0.1:6379&gt; setbit unique:users:20201103 1 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit unique:users:20201103 4 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit unique:users:20201103 9 1<br>(integer) 0<br>127.0.0.1:6379&gt; bitop and unique:users:20201104 unique:users:20201103 # 统计两天都访问网站的人数<br>(integer) 2<br></code></pre></td></tr></table></figure><h3 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6.2 HyperLogLog"></a>6.2 HyperLogLog</h3><h4 id="6-2-1-HyperLogLog简介"><a href="#6-2-1-HyperLogLog简介" class="headerlink" title="6.2.1 HyperLogLog简介"></a>6.2.1 HyperLogLog简介</h4><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。</p><p>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？<strong>这种求集合中不重复元素个数的问题称为基数问题。</strong></p><p>解决基数问题有很多种方案：</p><p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p><p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>什么是基数?</p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h4 id="6-2-2-命令操作"><a href="#6-2-2-命令操作" class="headerlink" title="6.2.2 命令操作"></a>6.2.2 命令操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; pfadd subject java  # 添加元素<br>(integer) 1<br>127.0.0.1:6379&gt; pfadd subject php<br>(integer) 1<br>127.0.0.1:6379&gt; pfadd subject java<br>(integer) 0<br>127.0.0.1:6379&gt; pfadd subject mysql<br>(integer) 1<br>127.0.0.1:6379&gt; pfadd subject html spring <br>(integer) 1<br>127.0.0.1:6379&gt; pfcount subject  # 统计元素的个数<br>(integer) 5<br>127.0.0.1:6379&gt; pfadd program oracle springboot<br>(integer) 1<br>127.0.0.1:6379&gt; pfcount program<br>(integer) 2<br>127.0.0.1:6379&gt; pfmerge k1 subject program  # 将两个key所属的元素合并到k1里面去。<br>OK<br>127.0.0.1:6379&gt; pfcount k1<br>(integer) 7<br></code></pre></td></tr></table></figure><h3 id="6-3-Geospatial"><a href="#6-3-Geospatial" class="headerlink" title="6.3 Geospatial"></a>6.3 Geospatial</h3><h4 id="6-3-1-Geospatial简介"><a href="#6-3-1-Geospatial简介" class="headerlink" title="6.3.1 Geospatial简介"></a>6.3.1 Geospatial简介</h4><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><h4 id="6-3-2-命令操作"><a href="#6-3-2-命令操作" class="headerlink" title="6.3.2 命令操作"></a>6.3.2 命令操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai #存数据<br>(integer) 1<br>127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing # 也可以批量存储数据<br>(integer) 3<br>127.0.0.1:6379&gt; geopos china:city shanghai  # 获取指定城市的经纬度<br>1) 1) &quot;121.47000163793563843&quot;<br>   2) &quot;31.22999903975783553&quot;<br>127.0.0.1:6379&gt; geopos china:city  beijing<br>1) 1) &quot;116.38000041246414185&quot;<br>   2) &quot;39.90000009167092543&quot;<br>127.0.0.1:6379&gt; geodist china:city beijing shanghai  # 显示北京到上海之间的直线距离(米)<br>&quot;1068153.5181&quot;<br>127.0.0.1:6379&gt; geodist china:city beijing shanghai km   # 显示北京到上海之间的直线距离(千米)<br>&quot;1068.1535&quot;<br>127.0.0.1:6379&gt; georadius china:city 110 30 1000 km  # 找出东经110度 北纬30度 1000公里半径内的城市<br>1) &quot;chongqing&quot;<br>2) &quot;shenzhen&quot;<br></code></pre></td></tr></table></figure><p><strong>注意：两极(南极 北极)无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。当坐标位置超出指定范围时，该命令将会返回一个错误。已经添加的数据，是无法再次往里面添加的。</strong></p><h2 id="7-redis的事务操作"><a href="#7-redis的事务操作" class="headerlink" title="7 redis的事务操作"></a>7 redis的事务操作</h2><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><h3 id="7-1-事务的基本操作"><a href="#7-1-事务的基本操作" class="headerlink" title="7.1 事务的基本操作"></a>7.1 事务的基本操作</h3><h4 id="7-1-1-redis事务命令的使用"><a href="#7-1-1-redis事务命令的使用" class="headerlink" title="7.1.1 redis事务命令的使用"></a>7.1.1 redis事务命令的使用</h4><ul><li><p>multi   从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行。</p></li><li><p>exec   输入exec后，Redis会将之前的命令队列中的命令依次执行。</p></li><li><p>discard  放弃将队列中的命令执行</p></li></ul><p><img src="20221004171957.png" style="zoom:60%"></p><p>使用案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi  # 开启事务<br>OK<br>127.0.0.1:6379(TX)&gt; set k1 v1 # 命令1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; set k2 v2 # 命令2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; get k1  # 命令3<br>QUEUED<br>127.0.0.1:6379(TX)&gt; get k2  # 命令4<br>QUEUED<br>127.0.0.1:6379(TX)&gt; exec  # 提交事务 事务中的所有命令都会执行<br>1) OK<br>2) OK<br>3) &quot;v1&quot;<br>4) &quot;v2&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; set k1 v1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; get k1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; get k2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; discard # 打断事务，事务中的所有命令都不会执行<br>OK<br>127.0.0.1:6379&gt; get k1<br>(nil)<br>127.0.0.1:6379&gt; get k2<br>(nil)<br></code></pre></td></tr></table></figure><h4 id="7-1-2-事务的错误处理"><a href="#7-1-2-事务的错误处理" class="headerlink" title="7.1.2 事务的错误处理"></a>7.1.2 事务的错误处理</h4><ul><li>组队中某个命令出现了报告错误(组队时出现错误)，执行时整个的所有队列都会被取消。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi <br>OK<br>127.0.0.1:6379(TX)&gt; set k1 v1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; set k2  # 由于命令出了语法问题，所以在入列的时候就会报错<br>(error) ERR wrong number of arguments for &#x27;set&#x27; command<br>127.0.0.1:6379(TX)&gt; get k1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; get k2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; exec  # 由于组队的时候就出现了错误，所以所有的redis指令都不会执行<br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; get k1<br>(nil)<br>127.0.0.1:6379&gt; get k2<br>(nil)<br></code></pre></td></tr></table></figure><ul><li>组队中(入列时)命令没有问题，在执行的时候出了问题，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; set k1 v1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; incr k1  # 语法没有问题，在执行的时候会出问题，因为只有数字才能自增<br>QUEUED<br>127.0.0.1:6379(TX)&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; get k1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; exec<br>1) OK<br>2) (error) ERR value is not an integer or out of range<br>3) OK<br>4) &quot;v1&quot;<br></code></pre></td></tr></table></figure><h3 id="7-2-事务的冲突"><a href="#7-2-事务的冲突" class="headerlink" title="7.2 事务的冲突"></a>7.2 事务的冲突</h3><h4 id="7-2-1-事务冲突出现的场景"><a href="#7-2-1-事务冲突出现的场景" class="headerlink" title="7.2.1 事务冲突出现的场景"></a>7.2.1 事务冲突出现的场景</h4><p>想想一个场景：有很多人有你的账户,同时去参加双十一抢购</p><p>假设你有一个账户，此时你有三个女友(A  B  C)都知道你账户，现在她们拿着你的银行账户同时进行消费。</p><p>一个请求想给金额减8000；一个请求想给金额减5000；一个请求想给金额减1000</p><p><img src="20221004180704.png" style="zoom:80%"></p><h4 id="7-2-2-解决事务的冲突问题"><a href="#7-2-2-解决事务的冲突问题" class="headerlink" title="7.2.2 解决事务的冲突问题"></a>7.2.2 解决事务的冲突问题</h4><ul><li>悲观锁</li></ul><p><img src="20221004180829.png" style="zoom:80%"></p><p><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><ul><li>乐观锁</li></ul><p><img src="20221004181028.png" style="zoom:80%"></p><p><strong>乐观锁(Optimistic Lock),</strong> 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p><h4 id="7-2-3-使用watch命令实现redis乐观锁"><a href="#7-2-3-使用watch命令实现redis乐观锁" class="headerlink" title="7.2.3 使用watch命令实现redis乐观锁"></a>7.2.3 使用watch命令实现redis乐观锁</h4><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</strong></p><p>现在我们使用两个客户端来演示redis的乐观锁</p><ul><li>在客户端1 设置一个balance，然后watch这个key</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set balance 100  # 设置账户余额信息 100<br>OK<br>127.0.0.1:6379&gt; watch balance  # 使用watch指令监控这个key值<br>OK<br></code></pre></td></tr></table></figure><ul><li>在客户端2 也watch这个key</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; watch balance  # 使用watch指令监控这个key值<br>OK<br></code></pre></td></tr></table></figure><ul><li>在客户端1开启事务，并修改账户余额信息，但是不提交事务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; decrby balance 20<br>QUEUED<br></code></pre></td></tr></table></figure><ul><li>在客户端2开启事务，并修改账户余额信息，但是不提交事务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; decrby balance 30<br>QUEUED<br></code></pre></td></tr></table></figure><ul><li>客户端1提交事务,查看效果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379(TX)&gt; exec<br>1) (integer) 80<br>127.0.0.1:6379&gt; get balance<br>&quot;80&quot;<br></code></pre></td></tr></table></figure><ul><li>客户端2提交事务,查看效果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379(TX)&gt; exec  # 事务中的命令没有被执行，因为客户端2监控的key值发生了变化<br>(nil)<br>127.0.0.1:6379&gt; get balance<br>&quot;80&quot;<br></code></pre></td></tr></table></figure><h4 id="7-2-4-redis事务的特性"><a href="#7-2-4-redis事务的特性" class="headerlink" title="7.2.4 redis事务的特性"></a>7.2.4 redis事务的特性</h4><ul><li><p>单独的隔离操作 </p><ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </li></ul></li><li><p>没有隔离级别的概念 </p><ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</li></ul></li><li><p>不保证原子性 </p><ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</li></ul></li></ul><h2 id="8-redis持久化操作"><a href="#8-redis持久化操作" class="headerlink" title="8 redis持久化操作"></a>8 redis持久化操作</h2><p><img src="20221004211921.png" style="zoom:80%"></p><p>Redis 提供了2个不同形式的持久化方式。</p><ul><li>RDB（Redis DataBase）</li><li>AOF（Append Of File）</li></ul><h3 id="8-1-RDB持久化"><a href="#8-1-RDB持久化" class="headerlink" title="8.1 RDB持久化"></a>8.1 RDB持久化</h3><h4 id="8-1-1-什么是RDB持久化"><a href="#8-1-1-什么是RDB持久化" class="headerlink" title="8.1.1 什么是RDB持久化"></a>8.1.1 什么是RDB持久化</h4><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p><h4 id="8-1-2-RDB持久化流程"><a href="#8-1-2-RDB持久化流程" class="headerlink" title="8.1.2 RDB持久化流程"></a>8.1.2 RDB持久化流程</h4><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失。</strong></p><p><img src="20221004215739.png" style="zoom:60%"></p><h4 id="8-1-3-RDB持久化触发策略"><a href="#8-1-3-RDB持久化触发策略" class="headerlink" title="8.1.3 RDB持久化触发策略"></a>8.1.3 RDB持久化触发策略</h4><p>RDB 持久化提供了两种触发策略：一种是手动触发，另一种是自动触发。</p><ul><li>手动触发策略</li></ul><p>手动触发是通过<code>SAVE</code>命令或者<code>BGSAVE</code>命令将内存数据保存到磁盘文件+中。如下所示：</p><p>save：会阻塞当前Redis服务器，直到持久化完成，<strong>线上应该禁止使用</strong>。</p><p>bgsave：该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; SAVE<br>OK<br>127.0.0.1:6379&gt; BGSAVE<br>Background saving started<br>127.0.0.1:6379&gt;  LASTSAVE<br>(integer) 1611298430<br></code></pre></td></tr></table></figure><ul><li>自动触发</li></ul><p>自动触发策略，是指 Redis 在指定的时间内，数据发生了多少次变化时，会自动执行<code>BGSAVE</code>命令。自动触发的条件包含在了 Redis 的配置文件中，如下所示：</p><p><img src="20221004215333.png" style="zoom:80%"></p><p>上图所示， save m n 的含义是在时间 m 秒内，如果 Redis 数据至少发生了 n 次变化，那么就自动执行<code>BGSAVE</code>命令。配置策略说明如下：</p><p>上图所示， save m n 的含义是在时间 m 秒内，如果 Redis 数据至少发生了 n 次变化，那么就自动执行<code>BGSAVE</code>命令。配置策略说明如下：</p><p>① save 900 1 表示在 900 秒内，至少更新了 1 条数据，Redis 自动触发 BGSAVE 命令，将数据保存到硬盘。</p><p>② save 300 10 表示在 300 秒内，至少更新了 10 条数据，Redis 自动触 BGSAVE 命令，将数据保存到硬盘。</p><p>③ save 60 10000 表示 60 秒内，至少更新了 10000 条数据，Redis 自动触发 BGSAVE 命令，将数据保存到硬盘。只要上述三个条件任意满足一个，服务器就会自动执行<code>BGSAVE</code>命令。当然您可以根据实际情况自己调整触发策略。</p><h4 id="8-1-4-dump-rdb文件"><a href="#8-1-4-dump-rdb文件" class="headerlink" title="8.1.4 dump.rdb文件"></a>8.1.4 dump.rdb文件</h4><p>在redis.conf中配置文件名称，默认为dump.rdb。</p><p><img src="20221004220227.png" style="zoom:90%"></p><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下,我们也可以自定义目录位置。</p><p><img src="20221004220351.png" style="zoom:90%"></p><h4 id="8-1-5-stop-writes-on-bgsave-error"><a href="#8-1-5-stop-writes-on-bgsave-error" class="headerlink" title="8.1.5 stop-writes-on-bgsave-error"></a>8.1.5 stop-writes-on-bgsave-error</h4><p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes。</p><p><img src="20221004220533.png" style="zoom:90%"></p><h4 id="8-1-6-RDB持久化特点"><a href="#8-1-6-RDB持久化特点" class="headerlink" title="8.1.6 RDB持久化特点"></a>8.1.6 RDB持久化特点</h4><ul><li><p>优势：</p><ul><li><p>适合大规模的数据恢复</p></li><li><p>对数据完整性和一致性要求不高更适合使用</p></li><li><p>节省磁盘空间</p></li><li><p>恢复速度快</p></li></ul></li><li><p>劣势</p><ul><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。</li><li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能。</li><li>l在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li></ul></li></ul><h3 id="8-2-AOF持久化"><a href="#8-2-AOF持久化" class="headerlink" title="8.2 AOF持久化"></a>8.2 AOF持久化</h3><p>AOF：append only file</p><h4 id="8-2-1-什么是AOF持久化"><a href="#8-2-1-什么是AOF持久化" class="headerlink" title="8.2.1 什么是AOF持久化"></a>8.2.1 什么是AOF持久化</h4><p>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p><strong>注意：AOF默认不开启。可以在redis.conf中配置文件名称，默认为 appendonly.aof。AOF文件的保存路径，同RDB的路径一致。</strong></p><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）。</p><h4 id="8-2-2-AOF持久化规则"><a href="#8-2-2-AOF持久化规则" class="headerlink" title="8.2.2 AOF持久化规则"></a>8.2.2 AOF持久化规则</h4><ul><li>appendfsync always</li></ul><p>始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</p><ul><li>appendfsync everysec</li></ul><p>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p><ul><li>appendfsync no</li></ul><p>redis不主动进行同步，把同步时机交给操作系统。</p><h4 id="8-2-3-ReWrite重写机制"><a href="#8-2-3-ReWrite重写机制" class="headerlink" title="8.2.3 ReWrite重写机制"></a>8.2.3 ReWrite重写机制</h4><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p><p>如何重写?</p><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p><p>no-appendfsync-on-rewrite：</p><p>如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p><p>如果 no-appendfsync-on-rewrite=no, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p><p>触发机制，何时重写？</p><p><strong>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</strong></p><p><strong>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。</strong> </p><p><strong>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</strong></p><p><strong>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</strong></p><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p><p>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。</p><h4 id="8-2-4-使用AOF持久化流程"><a href="#8-2-4-使用AOF持久化流程" class="headerlink" title="8.2.4 使用AOF持久化流程"></a>8.2.4 使用AOF持久化流程</h4><p><img src="20221004233837.png" style="zoom:80%"></p><p>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</p><p>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p><p>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</p><p>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p><p>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p><h4 id="8-2-5-AOF持久化特点"><a href="#8-2-5-AOF持久化特点" class="headerlink" title="8.2.5 AOF持久化特点"></a>8.2.5 AOF持久化特点</h4><ul><li><p>优势</p><ul><li>备份机制更稳健，丢失数据概率更低。</li><li>可读的日志文本，通过操作AOF稳健，可以处理误操作。</li></ul></li><li><p>劣势</p><ul><li>比起RDB占用更多的磁盘空间。</li><li>恢复备份速度要慢。</li><li>每次读写都同步的话，有一定的性能压力。</li></ul></li></ul><h4 id="8-2-6-用哪个"><a href="#8-2-6-用哪个" class="headerlink" title="8.2.6 用哪个"></a>8.2.6 用哪个</h4><p>官方推荐两个都启用。</p><p><img src="20221004234459.png" style="zoom:80%"></p><ul><li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</p></li><li><p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. </p></li><li><p>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</p></li><li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p></li><li><p>同时开启两种持久化方式</p><ul><li><p>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p></li><li><p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ 建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p></li></ul></li></ul><h2 id="9-redis主从复制"><a href="#9-redis主从复制" class="headerlink" title="9 redis主从复制"></a>9 redis主从复制</h2><p>什么是主从复制?</p><p>主机数据更新后根据配置和策略， 自动同步到备机的机制。主机就是master，备机就是slave。</p><p>主从复制的机制能干嘛：</p><ul><li><p>读写分离，性能扩展</p></li><li><p>容灾快速恢复</p></li></ul><p><img src="20221006132124.png" style="zoom:60%"></p><h3 id="9-1-搭建一主多从"><a href="#9-1-搭建一主多从" class="headerlink" title="9.1 搭建一主多从"></a>9.1 搭建一主多从</h3><p>如何搭建?</p><p>拷贝多个redis.conf文件include(写绝对路径)</p><p>开启daemonize yes</p><p>Pid文件名字pidfile</p><p>指定端口port</p><p>Log文件名字</p><p>dump.rdb名字dbfilename</p><p><strong>appendonly 关掉</strong></p><h4 id="9-1-1-搭建步骤"><a href="#9-1-1-搭建步骤" class="headerlink" title="9.1.1 搭建步骤"></a>9.1.1 搭建步骤</h4><ul><li><strong>新建一个目录，存放redis的配置文件</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine /]~$ mkdir myredis<br>[qgc@qgc-virtual-machine myredis]~$ cd myredis/<br>[qgc@qgc-virtual-machine myredis]~$ cp /usr/local/bin/redis.conf redis.conf<br>[qgc@qgc-virtual-machine myredis]~$ ll<br>总用量 92<br>-rw-r--r-- 1 root root 92263 9月   2 14:15 redis.conf<br></code></pre></td></tr></table></figure><ul><li><strong>新建redis6379.conf，在配置文件中定义以下内容</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ vim redis6379.conf<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">include /myredis/redis.conf<br>pidfile /var/run/redis_6379.pid<br>port 6379<br>dbfilename dump6379.rdb<br></code></pre></td></tr></table></figure><ul><li><strong>新建redis6380.conf，在配置文件中定义以下内容</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ vim redis6380.conf<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">include /myredis/redis.conf<br>pidfile /var/run/redis_6380.pid<br>port 6380<br>dbfilename dump6380.rdb<br></code></pre></td></tr></table></figure><ul><li><strong>新建redis6381.conf，在配置文件中定义以下内容</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ vim redis6381.conf<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">include /myredis/redis.conf<br>pidfile /var/run/redis_6381.pid<br>port 6381<br>dbfilename dump6381.rdb<br></code></pre></td></tr></table></figure><ul><li><strong>分别启动三台redis服务器</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ redis-server redis6379.conf <br>[qgc@qgc-virtual-machine myredis]~$ redis-server redis6380.conf <br>[qgc@qgc-virtual-machine myredis]~$ redis-server redis6381.conf <br>[qgc@qgc-virtual-machine myredis]~$ ps -ef | grep redis<br>root       3012      1  0 14:45 ?        00:00:00 redis-server 127.0.0.1:6379<br>root       3018      1  0 14:46 ?        00:00:00 redis-server 127.0.0.1:6380<br>root       3024      1  0 14:46 ?        00:00:00 redis-server 127.0.0.1:6381<br>root       3030   2541  0 14:46 pts/0    00:00:00 grep --color=auto redis<br></code></pre></td></tr></table></figure><ul><li><strong>查看三台主机运行情况</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ redis-cli -p 6379  # 使用客户端连接6379服务器<br>127.0.0.1:6379&gt; info replication  # 查看redis服务器运行情况<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:master  # 角色 主机<br>connected_slaves:0  # 从机数量为0<br>master_failover_state:no-failover<br>master_replid:309b974023e0e99b1a1b9ab508a3cdef86d8b281<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ redis-cli -p 6380  # 使用客户端连接6379服务器<br>127.0.0.1:6380&gt; info replication  # 查看redis服务器运行情况<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:master  # 角色 主机<br>connected_slaves:0  # 从机数量为0<br>master_failover_state:no-failover<br>master_replid:309b974023e0e99b1a1b9ab508a3cdef86d8b281<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ redis-cli -p 6381  # 使用客户端连接6379服务器<br>127.0.0.1:6381&gt; info replication  # 查看redis服务器运行情况<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:master  # 角色 主机<br>connected_slaves:0  # 从机数量为0<br>master_failover_state:no-failover<br>master_replid:309b974023e0e99b1a1b9ab508a3cdef86d8b281<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure><ul><li><strong>配置从机</strong></li></ul><p>在6380 6380服务器上配置从机角色。6379是主机，不做任何配置。</p><p>在redis6380.conf  6381.conf配置文件上配置从机</p><p>首选我们关掉redis三台服务器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[qgc@qgc-virtual-machine]~$ </span><span class="language-bash">redis-cli -p 6379 shutdown</span><br><span class="hljs-meta prompt_">[qgc@qgc-virtual-machine]~$ </span><span class="language-bash">redis-cli -p 6380 shutdown</span><br><span class="hljs-meta prompt_">[qgc@qgc-virtual-machine]~$ </span><span class="language-bash">redis-cli -p 6381 shutdown</span><br></code></pre></td></tr></table></figure><p>分别在redis6380.conf  6381.conf配置文件中添加： slaveof 127.0.0.1 6379</p><ul><li><strong>重启三台redis服务器,查看相关的服务器的运行信息</strong></li></ul><p>重启之后，分别查看相关的服务器的运行信息</p><p><strong>redis6379:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[qgc@qgc-virtual-machine]~$ </span><span class="language-bash">redis-cli -p 6379</span><br>127.0.0.1:6379&gt; info replication<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:master  # 主机<br>connected_slaves:2  # 从机的数量<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=42,lag=0  # 从机的具体状态<br>slave1:ip=127.0.0.1,port=6381,state=online,offset=28,lag=1  # 从机的具体状态<br>master_failover_state:no-failover<br>master_replid:df8e8d5239e9e60712e03aef99e38dc2954ef428<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:42<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:42<br></code></pre></td></tr></table></figure><p><strong>redis6380 redis6381:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[qgc@qgc-virtual-machine]~$ </span><span class="language-bash">redis-cli -p 6380</span><br>127.0.0.1:6380&gt; info replication<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:slave  # 角色 从机<br>master_host:127.0.0.1<br>master_port:6379<br>master_link_status:up<br>master_last_io_seconds_ago:8<br>master_sync_in_progress:0<br>slave_repl_offset:56<br>slave_priority:100<br>slave_read_only:1<br>connected_slaves:0<br>master_failover_state:no-failover<br>master_replid:df8e8d5239e9e60712e03aef99e38dc2954ef428<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:56<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:56<br></code></pre></td></tr></table></figure><ul><li><strong>测试redis主从复制是否可用</strong></li></ul><p>在主机上添加数据，在从机上查看：</p><p>在redis6379机器上设置数据:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set username eric<br>OK<br></code></pre></td></tr></table></figure><p>在从机redis6380 redis6381上查看数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; get username<br>&quot;eric&quot;<br>127.0.0.1:6381&gt; get username<br>&quot;eric&quot;<br></code></pre></td></tr></table></figure><p>在从机上写数据，看是否可以写成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; set k1 v1<br>(error) READONLY You can&#x27;t write against a read only replica.  # 不能写数据，因为从机只能读数据<br>127.0.0.1:6381&gt; set k2 v2<br>(error) READONLY You can&#x27;t write against a read only replica.<br></code></pre></td></tr></table></figure><h4 id="9-1-2-主从复制的原理"><a href="#9-1-2-主从复制的原理" class="headerlink" title="9.1.2 主从复制的原理"></a>9.1.2 主从复制的原理</h4><p>首先我们思考几个问题：</p><p><strong>(1) 从机挂掉之后，会出现什么情况</strong></p><p>我们先停掉redis6381这台机器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6381&gt; shutdown<br>not connected&gt; exit<br>[qgc@qgc-virtual-machine myredis]~$ ps -ef | grep redis<br>root       3956      1  0 15:49 ?        00:00:00 redis-server 127.0.0.1:6379<br>root       3962      1  0 15:49 ?        00:00:00 redis-server 127.0.0.1:6380<br>root       3975   3807  0 15:49 pts/0    00:00:00 redis-cli -p 6379<br>root       3987   3864  0 15:49 pts/1    00:00:00 redis-cli -p 6380<br>root       4002   3905  0 15:50 pts2    00:00:00 grep --color=auto redis<br></code></pre></td></tr></table></figure><p>接下来我们在主机上新增数据:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set k1 v1<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) &quot;username&quot;<br>2) &quot;k1&quot;<br></code></pre></td></tr></table></figure><p>在6380这台从机上能够同步到主机上的最新的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; keys *<br>1) &quot;k1&quot;<br>2) &quot;username&quot;<br></code></pre></td></tr></table></figure><p>接下来我们重启redis6381这台机器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ redis-server redis6381.conf <br>[qgc@qgc-virtual-machine myredis]~$ redis-cli -p 6381<br>127.0.0.1:6381&gt; info replication<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:slave  # 重启之后 角色没有发生变化，依然是从机<br>master_host:127.0.0.1<br>master_port:6379<br></code></pre></td></tr></table></figure><p>接下来我们查看redis6381这台机器上的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6381&gt; keys *<br>1) &quot;k1&quot;   # 依然能够同步到主机上最新的数据<br>2) &quot;username&quot;<br></code></pre></td></tr></table></figure><p><strong>(2) 如果主机挂掉之后，是什么情况</strong></p><p>我们关闭主机redis6379的服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; shutdown<br>not connected&gt; exit<br>[qgc@qgc-virtual-machine myredis]~$ ps -ef | grep redis<br>root       3962      1  0 15:49 ?        00:00:00 redis-server 127.0.0.1:6380<br>root       3987   3864  0 15:49 pts/1    00:00:00 redis-cli -p 6380<br>root       4022      1  0 15:52 ?        00:00:00 redis-server 127.0.0.1:6381<br>root       4036   3905  0 15:53 pts2    00:00:00 redis-cli -p 6381<br>root       4054   3807  0 15:55 pts/0    00:00:00 grep --color=auto redis<br></code></pre></td></tr></table></figure><p>此时从机的状态会发生变化吗?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; info replication  # 从机6380机器上的状态<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:slave<br>master_host:127.0.0.1<br>master_port:6379<br>master_link_status:down<br><br>127.0.0.1:6381&gt; info replication # 从机6381机器上的状态<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:slave<br>master_host:127.0.0.1<br>master_port:6379<br>master_link_status:down<br></code></pre></td></tr></table></figure><p><strong>我们发现，不管主机的状态是什么样，从机的角色永远不会发生变化。</strong></p><p><strong>(3) 主从复制的原理</strong></p><ul><li>Slave启动成功连接到master后会发送一个sync命令。</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步。</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步。</li><li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行。</li></ul><p><img src="20221006155905.png" style="zoom:80%"></p><h4 id="9-1-3-redis薪火相传和反客为主"><a href="#9-1-3-redis薪火相传和反客为主" class="headerlink" title="9.1.3 redis薪火相传和反客为主"></a>9.1.3 redis薪火相传和反客为主</h4><h5 id="9-1-3-1-薪火相传"><a href="#9-1-3-1-薪火相传" class="headerlink" title="9.1.3.1 薪火相传"></a>9.1.3.1 薪火相传</h5><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p><p><strong>风险是一旦某个slave宕机，后面的slave都没法备份。</strong></p><p>现在我们实现薪火相传的效果:</p><p><strong>搭建redis6382,注意，redis6382是redis6381的从机。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ vim redis6382.conf<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">include /myredis/redis.conf<br>pidfile /var/run/redis_6382.pid<br>port 6382<br>dbfilename dump6382.rdb<br>slaveof 127.0.0.1 6381  # 不是6379<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ redis-server redis6382.conf #启动redis6382<br>[qgc@qgc-virtual-machine myredis]~$ redis-cli -p 6382<br>127.0.0.1:6382&gt; info replication<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:slave<br>master_host:127.0.0.1<br>master_port:6381  # 我们发现6381是6382的主机<br></code></pre></td></tr></table></figure><p>我们再查看redis6381的状态：</p><p><img src="image-20230902151519367.png" alt="image-20230902151519367"></p><p>我们发现redis6380既是从机还是6382的主机。</p><p><strong>注意:6381还是只能提供读的服务，不能写数据，它的作用是分担了6379机器数据同步的压力。</strong></p><h5 id="9-1-3-2-反客为主"><a href="#9-1-3-2-反客为主" class="headerlink" title="9.1.3.2 反客为主"></a>9.1.3.2 反客为主</h5><p>在默认情况下，如果主机挂了，从机的角色不会发生变化，永远都是从机的角色。如果我们想主机挂了之后，从机的角色发生转换，转换成主机，这就叫反客为主。</p><ul><li>关闭主机redis6379</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; shutdown<br>not connected&gt; exit<br></code></pre></td></tr></table></figure><ul><li>把从机redis6380设置成主机</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; slaveof no one<br>OK<br>127.0.0.1:6380&gt; info replication<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:master<br>127.0.0.1:6380&gt; set k2 v2  # 可以存数据了<br>OK<br></code></pre></td></tr></table></figure><ul><li>在从机上取数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6381&gt; slaveof 127.0.0.1 6380  # 重新指定其主机是6380<br>OK<br>127.0.0.1:6381&gt; keys *<br>1) &quot;k1&quot;<br>2) &quot;username&quot;<br>3) &quot;k2&quot;<br>127.0.0.1:6381&gt; get k2<br>&quot;v2&quot;<br></code></pre></td></tr></table></figure><h3 id="9-2-哨兵模式"><a href="#9-2-哨兵模式" class="headerlink" title="9.2 哨兵模式"></a>9.2 哨兵模式</h3><p>什么是哨兵模式：</p><p><strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从节点切换成主节点。</p><p><img src="20221006172820.png" style="zoom:80%"></p><h4 id="9-2-1-搭建哨兵模式的步骤"><a href="#9-2-1-搭建哨兵模式的步骤" class="headerlink" title="9.2.1 搭建哨兵模式的步骤"></a>9.2.1 搭建哨兵模式的步骤</h4><ul><li>将机器恢复成6379 6380 6381</li></ul><p>其中6379是主节点。6380   6381是从节点。分别启动这三台redis服务。</p><ul><li>在myredis目录里面创建一个文件，文件的名称为<strong>sentinel.conf</strong>。注意名字必须叫这个。</li></ul><p>在sentinel.conf配置文件里面定义如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sentinel monitor mymaster 127.0.0.1 6379 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">daemonize <span class="hljs-built_in">yes</span> <span class="hljs-comment"># yes表示后台启动</span></span><br></code></pre></td></tr></table></figure><p>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。</p><ul><li>启动哨兵</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ redis-sentinel sentinel.conf<br></code></pre></td></tr></table></figure><p><img src="image-20230902153746240.png" alt="image-20230902153746240"></p><p>我们可以看到哨兵监控的具体信息:</p><p><img src="image-20230902154006054.png" alt="image-20230902154006054"></p><ul><li>将主机redis6379停掉</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ redis-cli -p 6379 shutdown<br></code></pre></td></tr></table></figure><p>我们再看sentinel控制台的输出(此时需要等待一定的时间)，我们可以看到切换主机的一些日志信息：</p><p><img src="image-20230902155923831.png" alt="image-20230902155923831"></p><ul><li>查看redis6381的服务器运行信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine ~]~$ redis-cli -p 6381<br>127.0.0.1:6381&gt; info replication<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:master  # 变成了主机<br>connected_slaves:1<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=36593,lag=0<br>master_failover_state:no-failover<br>master_replid:b6ff983efa23cafad22380a6d9d270eadcb69e99<br>master_replid2:8b338cbee4b296b50621911fd89d26d68c110b14<br>master_repl_offset:36593<br>second_repl_offset:14976<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:36593<br></code></pre></td></tr></table></figure><ul><li>接下来我们重新启动redis6379服务器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine myredis]~$ redis-cli -p 6379 shutdown<br>[qgc@qgc-virtual-machine myredis]~$ redis-server redis6379.conf <br>[qgc@qgc-virtual-machine myredis]~$ redis-cli -p 6379<br>127.0.0.1:6379&gt; info replication<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:slave  # 6379变成了从服务器了<br>master_host:127.0.0.1<br>master_port:6381<br></code></pre></td></tr></table></figure><p>现在我们完成了哨兵的配置。</p><h4 id="9-2-2-哨兵的选举策略"><a href="#9-2-2-哨兵的选举策略" class="headerlink" title="9.2.2 哨兵的选举策略"></a>9.2.2 哨兵的选举策略</h4><p>通过上面的操作，我们指定当从节点挂掉之后，哨兵会选出新的主节点，那么它的选举策略是什么呢?</p><p><strong>(1) 选择优先级靠前的。</strong></p><p>优先级在redis.conf中默认：replica-priority 100，值越小优先级越高</p><p><img src="20221006180734.png" style="zoom:90%"></p><p><strong>(2) 选择偏移量最大的。</strong></p><p>偏移量是指获得原主机数据最全的。</p><p><strong>(3) 选择runid最小的服务。</strong></p><p>每个redis实例启动后都会随机生成一个40位的runid。</p><h2 id="10-redis集群"><a href="#10-redis集群" class="headerlink" title="10 redis集群"></a>10 redis集群</h2><h3 id="10-1-redis集群的基本介绍"><a href="#10-1-redis集群的基本介绍" class="headerlink" title="10.1 redis集群的基本介绍"></a>10.1 redis集群的基本介绍</h3><p>首先我们来思考一个问题：</p><p>如果redis容量不够了，数据写不进去了，redis如何扩容?</p><p>如果redis的并发操作大，redis如何分摊并发压力?</p><p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p><p>之前通过<strong>代理主机</strong>来解决，但是redis3.0中提供了解决方案。<strong>就是无中心化集群配置。</strong></p><h3 id="10-2-搭建redis集群"><a href="#10-2-搭建redis集群" class="headerlink" title="10.2 搭建redis集群"></a>10.2 搭建redis集群</h3><p>redis集群有什么特点:</p><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p><p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><p>接下来我们开始redis集群的具体搭建：</p><ul><li><strong>创建新的目录</strong></li></ul><p>创建目录redis-cluster，将之前搭建主从复制的redis.conf拷贝到当前目录。</p><p><strong>注意：redis.conf配置文件一定要设置成远程登录，否则搭建集群不成功。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine /]~$ mkdir redis-cluster<br>[qgc@qgc-virtual-machine /]~$ cd redis-cluster<br>[qgc@qgc-virtual-machine redis-cluster]~$ cp /myredis/redis.conf redis.conf<br></code></pre></td></tr></table></figure><ul><li><strong>我们搭建3主3从，所以我们创建6个redis实例。</strong></li></ul><p>6个redis实例的端口号分别是<strong>6379,6380,6381,6389,6390,6391。</strong> </p><p>创建redis配置文件redis6379.conf，配置文件里面定义如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">include /redis-cluster/redis.conf<br>pidfile /var/run/redis_6379.pid<br>port 6379<br>dbfilename dump6379.rdb<br>cluster-enabled yes<br>cluster-config-file nodes-6379.conf<br>cluster-node-timeout 15000<br></code></pre></td></tr></table></figure><p>注意：</p><p>cluster-enabled yes  打开集群模式</p><p>cluster-config-file nodes-6379.conf 设定节点配置文件名</p><p>cluster-node-timeout 15000  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p><ul><li><strong>复制其他节点的配置文件</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine redis-cluster]~$ cp redis6379.conf redis6380.conf<br>[qgc@qgc-virtual-machine redis-cluster]~$ cp redis6379.conf redis6381.conf<br>[qgc@qgc-virtual-machine redis-cluster]~$ cp redis6379.conf redis6389.conf<br>[qgc@qgc-virtual-machine redis-cluster]~$ cp redis6379.conf redis6390.conf<br>[qgc@qgc-virtual-machine redis-cluster]~$ cp redis6379.conf redis6391.conf<br>[qgc@qgc-virtual-machine redis-cluster]~$ ll<br>总用量 24<br>-rw-r--r-- 1 root root   168 9月   2 16:08 redis6379.conf<br>-rw-r--r-- 1 root root   168 9月   2 16:08 redis6380.conf<br>-rw-r--r-- 1 root root   168 9月   2 16:08 redis6381.conf<br>-rw-r--r-- 1 root root   168 9月   2 16:08 redis6389.conf<br>-rw-r--r-- 1 root root   168 9月   2 16:08 redis6390.conf<br>-rw-r--r-- 1 root root   168 9月   2 16:08 redis6391.conf<br></code></pre></td></tr></table></figure><ul><li><strong>将配置文件里面的内容进行修改</strong></li></ul><p>可以使用查找并替换的命令来实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">:%s/6379/6380<br></code></pre></td></tr></table></figure><ul><li><strong>启动6个redis服务</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine redis-cluster]~$ redis-server redis6379.conf <br>[qgc@qgc-virtual-machine redis-cluster]~$ redis-server redis6380.conf <br>[qgc@qgc-virtual-machine redis-cluster]~$ redis-server redis6381.conf <br>[qgc@qgc-virtual-machine redis-cluster]~$ redis-server redis6389.conf <br>[qgc@qgc-virtual-machine redis-cluster]~$ redis-server redis6390.conf <br>[qgc@qgc-virtual-machine redis-cluster]~$ redis-server redis6391.conf <br></code></pre></td></tr></table></figure><p>查看redis服务启动状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine redis-cluster]~$ ps -ef | grep redis<br>root       8673      1  0 22:56 ?        00:00:00 redis-server 127.0.0.1:6379 [cluster]<br>root       8679      1  0 22:56 ?        00:00:00 redis-server 127.0.0.1:6380 [cluster]<br>root       8685      1  0 22:56 ?        00:00:00 redis-server 127.0.0.1:6381 [cluster]<br>root       8691      1  0 22:56 ?        00:00:00 redis-server 127.0.0.1:6389 [cluster]<br>root       8697      1  0 22:56 ?        00:00:00 redis-server 127.0.0.1:6390 [cluster]<br>root       8703      1  0 22:56 ?        00:00:00 redis-server 127.0.0.1:6391 [cluster]<br>root       8483   6637  0 22:45 pts/0    00:00:00 grep --color=auto redis<br></code></pre></td></tr></table></figure><p>注意：如果搭建成功，当前目录下面必须存在以nodes-开头的文件</p><p><img src="image-20230902162133335.png" alt="image-20230902162133335"></p><ul><li><strong>将6个节点合并成一个集群</strong></li></ul><p><strong>合并集群之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</strong></p><p>先进入到最先安装redis的src目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine /]~$ cd  /opt/redis-6.2.1/src<br>[qgc@qgc-virtual-machine src]~$ ls<br></code></pre></td></tr></table></figure><p><img src="20221006231006-1693643011635-20.png" style="zoom:70%"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine src]~$ redis-cli --cluster create --cluster-replicas 1 192.168.84.128:6379 192.168.84.128:6380 192.168.84.128:6381 192.168.84.128:6389 192.168.84.128:6390 192.168.84.128:6391<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p><strong>此处不要用127.0.0.1， 请用真实IP地址，请用ifconfig查看IP。</strong></p></li><li><p><strong>关于错误的解决方案</strong><img src="image-20230902163633612.png" alt="image-20230902163633612"></p><p><a href="https://blog.csdn.net/weixin_44829930/article/details/117558512">彻底解决：[ERR] Node is not empty. Either the node already knows other nodes_生命中有太多不确定的博客-CSDN博客</a></p></li></ul><p>**—replicas 1 采用最简单的方式配置集群，</p><p><strong>—replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</strong></p><p>执行命令，之后，效果如下:</p><p><img src="image-20230902163526991.png" alt="image-20230902163526991"></p><p>我们输入yes，表示接受以上配置：</p><p><img src="image-20230902163547260.png" alt="image-20230902163547260"></p><p>如果出现以上信息说明集群搭建成功。</p><ul><li><strong>连接集群</strong></li></ul><p>使用连接集群的命令： redis-cli -c -p 6379</p><p>-c:指的使用集群的方式连接redis。</p><p>-p：指定参数，这里任意参数都可以。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[qgc@qgc-virtual-machine src]~$ redis-cli -c -p 6379<br>127.0.0.1:6379&gt; cluster nodes # 查看集群的具体情况在<br></code></pre></td></tr></table></figure><h3 id="10-3-redis集群的详细细节"><a href="#10-3-redis集群的详细细节" class="headerlink" title="10.3 redis集群的详细细节"></a>10.3 redis集群的详细细节</h3><p>一个集群至少要有三个主节点。</p><p>选项 —cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</p><p><strong>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</strong></p><h4 id="10-3-1-什么是slots"><a href="#10-3-1-什么是slots" class="headerlink" title="10.3.1 什么是slots"></a>10.3.1 什么是slots</h4><p><img src="20221007000923.png" style="zoom:80%"></p><p>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个。</p><p>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p><p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p><p>节点 A 负责处理 0 号至 5460 号插槽。</p><p>节点 B 负责处理 5461 号至 10922 号插槽。</p><p>节点 C 负责处理 10923 号至 16383 号插槽。</p><h4 id="10-3-2-在集群模式写写入数据"><a href="#10-3-2-在集群模式写写入数据" class="headerlink" title="10.3.2 在集群模式写写入数据"></a>10.3.2 在集群模式写写入数据</h4><p>接下来我们在集群中插入数据:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set k1 v1<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [12706] located at 192.168.84.128:6381</span><br>OK<br>192.168.84.128:6381&gt; set k2 v2<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [449] located at 192.168.84.128:6379</span><br>OK<br>192.168.84.128:6379&gt;<br></code></pre></td></tr></table></figure><p><strong>注意：不在一个slot下的键值，是不能使用mget,mset等多键操作。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.84.128:6379&gt; mset username eric age 20<br>(error) CROSSSLOT Keys in request don&#x27;t hash to the same slot   # 此时报错<br></code></pre></td></tr></table></figure><p>我们可以通过{}来定义组的概念，从而使key中{}内相同内</p><p>容的键值对放到一个slot中去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.84.128:6379&gt; mset username&#123;group1&#125; eric age&#123;group1&#125; 20<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [7859] located at 192.168.84.128:6380</span><br>OK<br>192.168.84.128:6380&gt;<br></code></pre></td></tr></table></figure><h4 id="10-3-3-查询集群中的值"><a href="#10-3-3-查询集群中的值" class="headerlink" title="10.3.3 查询集群中的值"></a>10.3.3 查询集群中的值</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.84.128:6380&gt; cluster keyslot k2  # 计算key的插槽值<br>(integer) 449<br>192.168.84.128:6380&gt; get k1<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [12706] located at 192.168.84.128:6381</span><br>&quot;v1&quot;<br>192.168.84.128:6381&gt; get k2<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [449] located at 192.168.84.128:6379</span><br>&quot;v2&quot;<br>192.168.84.128:6381&gt; get username&#123;group1&#125;<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [7859] located at 192.168.84.128:6380</span><br>&quot;eric&quot;<br>192.168.84.128:6380&gt; get age&#123;group1&#125;<br>&quot;20&quot;<br></code></pre></td></tr></table></figure><h4 id="10-3-4-redis集群的故障恢复"><a href="#10-3-4-redis集群的故障恢复" class="headerlink" title="10.3.4 redis集群的故障恢复"></a>10.3.4 redis集群的故障恢复</h4><p>在redis集群中，如果某一个主节点挂掉(下线)，会出现什么样的后果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.84.128:6379&gt; shutdown  # 将6379服务停掉<br>not connected&gt; exit<br></code></pre></td></tr></table></figure><p><img src="image-20230903071255767.png" alt="image-20230903071255767"></p><p>现在我们重新启动6379这台机器，我们重新打开一个终端来启动:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@java2201 src]~$ cd /redis-cluster/<br>[root@java2201 redis-cluster]~$ redis-server redis6379.conf <br></code></pre></td></tr></table></figure><p><img src="image-20230903071625051.png" alt="image-20230903071625051"></p><p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</p><p>redis.conf中的参数 cluster-require-full-coverage</p><h2 id="11-Jedis操作"><a href="#11-Jedis操作" class="headerlink" title="11 Jedis操作"></a>11 Jedis操作</h2><p>前期准备工作:</p><p>禁用Linux的防火墙：Linux(CentOS7)里执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop/disable firewalld.service<br></code></pre></td></tr></table></figure><p><strong>redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no</strong></p><h3 id="11-1-搭建maven工程，测试jedis"><a href="#11-1-搭建maven工程，测试jedis" class="headerlink" title="11.1 搭建maven工程，测试jedis"></a>11.1 搭建maven工程，测试jedis</h3><ul><li>创建maven工程，引入相关的依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>创建测试程序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestJedis</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.84.128&quot;</span>,<span class="hljs-number">6379</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pong</span> <span class="hljs-operator">=</span> jedis.ping();<br>        System.out.println(<span class="hljs-string">&quot;连接成功：&quot;</span>+pong);<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-2-Jedis的基本使用"><a href="#11-2-Jedis的基本使用" class="headerlink" title="11.2 Jedis的基本使用"></a>11.2 Jedis的基本使用</h3><h4 id="11-2-1-使用jedis操作redis常用的数据类型"><a href="#11-2-1-使用jedis操作redis常用的数据类型" class="headerlink" title="11.2.1 使用jedis操作redis常用的数据类型"></a>11.2.1 使用jedis操作redis常用的数据类型</h4><ul><li>跟key相关的操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.84.128&quot;</span>,<span class="hljs-number">6379</span>);<br>    jedis.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>    jedis.set(<span class="hljs-string">&quot;k2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>);<br>    jedis.set(<span class="hljs-string">&quot;k3&quot;</span>, <span class="hljs-string">&quot;v3&quot;</span>);<br>    Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>    System.out.println(keys.size());<br>    <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>        System.out.println(key);<br>    &#125;<br>    System.out.println(jedis.exists(<span class="hljs-string">&quot;k1&quot;</span>));<br>    System.out.println(jedis.ttl(<span class="hljs-string">&quot;k1&quot;</span>));<br>    System.out.println(jedis.get(<span class="hljs-string">&quot;k1&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>操作String</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test03</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.84.128&quot;</span>,<span class="hljs-number">6379</span>);<br>    jedis.mset(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>);<br>    System.out.println(jedis.mget(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>操作list</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.84.128&quot;</span>,<span class="hljs-number">6379</span>);<br>    jedis.rpush(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>);<br>    List&lt;String&gt; list = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (String element : list) &#123;<br>        System.out.println(element);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>操作set</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.84.128&quot;</span>,<span class="hljs-number">6379</span>);<br>    jedis.sadd(<span class="hljs-string">&quot;myset&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>);<br>    Set&lt;String&gt; smembers = jedis.smembers(<span class="hljs-string">&quot;myset&quot;</span>);<br>    <span class="hljs-keyword">for</span> (String order : smembers) &#123;<br>        System.out.println(order);<br>    &#125;<br>    jedis.srem(<span class="hljs-string">&quot;myset&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>操作hash</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.84.128&quot;</span>,<span class="hljs-number">6379</span>);<br>    jedis.hset(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>    System.out.println(jedis.hget(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>));<br>    Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,String&gt;();<br>    map.put(<span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;13810169999&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;atguigu&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;email&quot;</span>,<span class="hljs-string">&quot;abc@163.com&quot;</span>);<br>    jedis.hmset(<span class="hljs-string">&quot;hash2&quot;</span>,map);<br>    List&lt;String&gt; result = jedis.hmget(<span class="hljs-string">&quot;hash2&quot;</span>, <span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;email&quot;</span>);<br>    <span class="hljs-keyword">for</span> (String element : result) &#123;<br>        System.out.println(element);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>操作zset</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.84.128&quot;</span>,<span class="hljs-number">6379</span>);<br>    jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">100d</span>, <span class="hljs-string">&quot;z3&quot;</span>);<br>    jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">90d</span>, <span class="hljs-string">&quot;l4&quot;</span>);<br>    jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">80d</span>, <span class="hljs-string">&quot;w5&quot;</span>);<br>    jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">70d</span>, <span class="hljs-string">&quot;z6&quot;</span>);<br><br>    Set&lt;String&gt; zrange = jedis.zrange(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (String e : zrange) &#123;<br>        System.out.println(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-2-2-使用jedis连接池改造jedis操作"><a href="#11-2-2-使用jedis连接池改造jedis操作" class="headerlink" title="11.2.2 使用jedis连接池改造jedis操作"></a>11.2.2 使用jedis连接池改造jedis操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test03</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>    config.setMaxTotal(<span class="hljs-number">50</span>);<br>    config.setMinIdle(<span class="hljs-number">10</span>);<br>    <span class="hljs-type">JedisPool</span> <span class="hljs-variable">jedisPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(config,<span class="hljs-string">&quot;192.168.84.128&quot;</span>,<span class="hljs-number">6379</span>);<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> jedisPool.getResource();<br>    jedis.set(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;eric&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;username&quot;</span>);<br>    System.out.println(username);<br>    jedis.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-2-3-抽取工具类，优化连接池代码"><a href="#11-2-3-抽取工具类，优化连接池代码" class="headerlink" title="11.2.3 抽取工具类，优化连接池代码"></a>11.2.3 抽取工具类，优化连接池代码</h4><ul><li>定义一个配置连接池的properties文件(redis.properties)，然后放置在resources目录下面。</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">maxTotal</span>=<span class="hljs-string">200</span><br><span class="hljs-attr">maxIdle</span>=<span class="hljs-string">50</span><br></code></pre></td></tr></table></figure><ul><li>定义一个工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> RedisUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;redis.properties&quot;</span>);<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            properties.load(in);<br>            <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>            config.setMaxTotal(Integer.parseInt(properties.getProperty(<span class="hljs-string">&quot;maxTotal&quot;</span>)));<br>            config.setMinIdle(Integer.parseInt(properties.getProperty(<span class="hljs-string">&quot;maxIdle&quot;</span>)));<br>            jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(config,<span class="hljs-string">&quot;192.168.84.128&quot;</span>,<span class="hljs-number">6379</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test04</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> RedisUtils.getJedis();<br>    jedis.set(<span class="hljs-string">&quot;subject&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;subject&quot;</span>);<br>    System.out.println(subject);<br>    jedis.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-3-jedis案例"><a href="#11-3-jedis案例" class="headerlink" title="11.3 jedis案例"></a>11.3 jedis案例</h3><p>需求：使用异步请求，动态加载下拉框省份信息。要求将省份信息保存在缓存里面。</p><h4 id="11-3-1-搭建maven工程-使用骨架创建web项目-，导入相关的依赖"><a href="#11-3-1-搭建maven工程-使用骨架创建web项目-，导入相关的依赖" class="headerlink" title="11.3.1 搭建maven工程(使用骨架创建web项目)，导入相关的依赖"></a>11.3.1 搭建maven工程(使用骨架创建web项目)，导入相关的依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slf4j.version</span>&gt;</span>1.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">slf4j.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">oracle.version</span>&gt;</span>11.2.0.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">oracle.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring.security.version</span>&gt;</span>5.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.security.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>5.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- spring --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- log start --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- log end --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--json工具--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="11-3-2-编写jsp页面"><a href="#11-3-2-编写jsp页面" class="headerlink" title="11.3.2 编写jsp页面"></a>11.3.2 编写jsp页面</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> isELIgnored=<span class="hljs-string">&quot;false&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;select name=<span class="hljs-string">&quot;province&quot;</span> id=<span class="hljs-string">&quot;province&quot;</span>&gt;<br>        &lt;option&gt;请选择&lt;/option&gt;<br>    &lt;/select&gt;<br>&lt;/body&gt;<br>&lt;script src=<span class="hljs-string">&quot;http://code.jquery.com/jquery-2.1.4.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    $(function()&#123;<br>        $.ajax(&#123;<br>            type:<span class="hljs-string">&quot;GET&quot;</span>,<br>            url:<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/province/findAll&quot;</span>,<br>            contentType:<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>,<br>            dataType:<span class="hljs-string">&quot;json&quot;</span>,<br>            success:function(data)&#123;<br>               $(data).each(function()&#123;<br>                   <span class="hljs-type">var</span> <span class="hljs-variable">option</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;option id=&quot;</span>+<span class="hljs-built_in">this</span>.id+<span class="hljs-string">&quot;&gt;&quot;</span>+<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;&lt;/option&gt;&quot;</span>;<br>                   $(<span class="hljs-string">&quot;#province&quot;</span>).append(option);<br>               &#125;)<br>            &#125;<br>        &#125;)<br>    &#125;)<br>&lt;/script&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h4 id="11-3-3-搭建SSM环境"><a href="#11-3-3-搭建SSM环境" class="headerlink" title="11.3.3 搭建SSM环境"></a>11.3.3 搭建SSM环境</h4><ul><li>编写web.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--加载spring配置文件的路径--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 解决中文乱码过滤器 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br><br>  <span class="hljs-comment">&lt;!--配置监听器--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><br><br>  <span class="hljs-comment">&lt;!--配置前端控制器--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--加载springmvc配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>编写applicationContext.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--包扫描--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.xq&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">context:exclude-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--加载外部的properties配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:property-placeholder</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置SqlSessionFactoryBean--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置MapperScannerConfigure--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mapperScannerConfigurer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.xq.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置redis--&gt;</span><br>    <span class="hljs-comment">&lt;!--配置JedisPoolConfig--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jedisPoolConfig&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxTotal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;redis.pool.maxActive&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;redis.pool.maxIdle&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;redis.pool.minIdle&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxWaitMillis&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;redis.pool.maxWaitMillis&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--管理JedisPool--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jedisPool&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;redis.clients.jedis.JedisPool&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolConfig&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;jedisPoolConfig&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;host&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;redis.host&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置平台事务管理器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--开启注解对事务的支持--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:annotation-driven</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>编写springmvc.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">   &quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--包扫描--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.xq&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:include-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 设置静态资源不过滤 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;</span><br><span class="hljs-comment">    &lt;mvc:resources location=&quot;img/&quot; mapping=&quot;img/**&quot; /&gt;</span><br><span class="hljs-comment">    &lt;mvc:resources location=&quot;/plugins/&quot; mapping=&quot;/plugins/**&quot; /&gt;</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-comment">&lt;!--配置视图解析器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/pages/&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--开启对处理器映射器 处理器适配器的支持--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>编写db.properties</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># mysql的配置信息</span><br><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://192.168.10.130:3306/redis</span><br><span class="hljs-attr">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">Admin2022!</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># redis的配置信息</span><br><span class="hljs-comment"># 最大分配的对象数</span><br><span class="hljs-attr">redis.pool.maxActive</span>=<span class="hljs-string">200</span><br><span class="hljs-comment"># 最大能够保持idel状态的对象数</span><br><span class="hljs-attr">redis.pool.maxIdle</span>=<span class="hljs-string">50</span><br><span class="hljs-attr">redis.pool.minIdle</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">redis.pool.maxWaitMillis</span>=<span class="hljs-string">20000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#  连接redis的主机和端口号</span><br><span class="hljs-attr">redis.host</span> = <span class="hljs-string">192.168.10.130</span><br></code></pre></td></tr></table></figure><ul><li>编写log4j.properties</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">log4j.rootLogger</span>=<span class="hljs-string">DEBUG,myConsole</span><br><span class="hljs-attr">log4j.appender.myConsole</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-attr">log4j.appender.myConsole.ImmediateFlush</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">log4j.appender.myConsole.Target</span>=<span class="hljs-string">System.out</span><br><span class="hljs-attr">log4j.appender.myConsole.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-attr">log4j.appender.myConsole.layout.ConversionPattern</span>=<span class="hljs-string">[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><br><span class="hljs-attr">log4j.logger.com.mchange.v2</span>=<span class="hljs-string">ERROR</span><br></code></pre></td></tr></table></figure><h4 id="11-3-4-编写实体类"><a href="#11-3-4-编写实体类" class="headerlink" title="11.3.4 编写实体类"></a>11.3.4 编写实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Province</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Province&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-3-5-编写dao"><a href="#11-3-5-编写dao" class="headerlink" title="11.3.5 编写dao"></a>11.3.5 编写dao</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProvinceDao</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from province&quot;)</span><br>    List&lt;Province&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-3-6-编写Service"><a href="#11-3-6-编写Service" class="headerlink" title="11.3.6 编写Service"></a>11.3.6 编写Service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProvinceService</span> &#123;<br>    String <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProvinceServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProvinceService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    ProvinceDao provinceDao;<br><br>    <span class="hljs-meta">@Autowired</span><br>    JedisPool jedisPool;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//首先从缓存里面获取数据，如果缓存里面能够获取到数据，就直接从缓存里面获取数据即可。</span><br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> jedisPool.getResource();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">province_name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;province_name&quot;</span>);<br>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(province_name))&#123;<br>            <span class="hljs-comment">//如果缓存里面没有数据，从数据库里面取数据</span><br>            List&lt;Province&gt; provinceList = provinceDao.findAll();<br>            <span class="hljs-comment">//将provinceList转换成json串</span><br>            <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>            <span class="hljs-comment">//将java数据类型转换成json数据</span><br>            province_name = mapper.writeValueAsString(provinceList);<br>            <span class="hljs-comment">//将数据放在缓存里面</span><br>            jedis.set(<span class="hljs-string">&quot;province_name&quot;</span>,province_name);<br>            <span class="hljs-keyword">return</span> province_name;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//缓存里面有数据</span><br>            <span class="hljs-keyword">return</span> province_name;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-3-7-编写Controller"><a href="#11-3-7-编写Controller" class="headerlink" title="11.3.7 编写Controller"></a>11.3.7 编写Controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;province&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProvinceController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    ProvinceService provinceService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;findAll&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findAll</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">json_String</span> <span class="hljs-operator">=</span> provinceService.findAll();<br>        <span class="hljs-comment">//向浏览器端响应json数据</span><br>        response.getWriter().write(json_String);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-4-springboot整合redis"><a href="#11-4-springboot整合redis" class="headerlink" title="11.4 springboot整合redis"></a>11.4 springboot整合redis</h3><h4 id="11-4-1-创建springboot工程，引入相关依赖"><a href="#11-4-1-创建springboot工程，引入相关依赖" class="headerlink" title="11.4.1 创建springboot工程，引入相关依赖"></a>11.4.1 创建springboot工程，引入相关依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--web启动器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- redis --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="11-4-2-编写启动器"><a href="#11-4-2-编写启动器" class="headerlink" title="11.4.2 编写启动器"></a>11.4.2 编写启动器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(App.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-4-3-编写配置文件"><a href="#11-4-3-编写配置文件" class="headerlink" title="11.4.3 编写配置文件"></a>11.4.3 编写配置文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#Redis服务器地址</span><br><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">192.168.10.130</span><br><span class="hljs-comment">#Redis服务器连接端口</span><br><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-comment">#Redis数据库索引（默认为0）</span><br><span class="hljs-attr">spring.redis.database</span>= <span class="hljs-string">0</span><br><span class="hljs-comment">#连接超时时间（毫秒）</span><br><span class="hljs-attr">spring.redis.timeout</span>=<span class="hljs-string">1800000</span><br><span class="hljs-comment">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-active</span>=<span class="hljs-string">20</span><br><span class="hljs-comment">#最大阻塞等待时间(负数表示没限制)</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-wait</span>=<span class="hljs-string">-1</span><br><span class="hljs-comment">#连接池中的最大空闲连接</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-idle</span>=<span class="hljs-string">5</span><br><span class="hljs-comment">#连接池中的最小空闲连接</span><br><span class="hljs-attr">spring.redis.lettuce.pool.min-idle</span>=<span class="hljs-string">0</span><br></code></pre></td></tr></table></figure><h4 id="11-4-3-编写配置类"><a href="#11-4-3-编写配置类" class="headerlink" title="11.4.3 编写配置类"></a>11.4.3 编写配置类</h4><p>配置类是固定的写法，我们直接引入即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xq.config;<br><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> org.springframework.cache.CacheManager;<br><span class="hljs-keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;<br><span class="hljs-keyword">import</span> org.springframework.cache.annotation.EnableCaching;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><br><span class="hljs-keyword">import</span> java.time.Duration;<br><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        template.setConnectionFactory(factory);<br>        <span class="hljs-comment">//key序列化方式</span><br>        template.setKeySerializer(redisSerializer);<br>        <span class="hljs-comment">//value序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">//value hashmap序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-comment">//解决查询缓存转换异常的问题</span><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        <span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))<br>                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))<br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br>        <span class="hljs-type">RedisCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-4-4-编写controller"><a href="#11-4-4-编写controller" class="headerlink" title="11.4.4 编写controller"></a>11.4.4 编写controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/redisTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRedis</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//设置值到redis</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;eric&quot;</span>);<br>        <span class="hljs-comment">//从redis获取值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String)redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-redis应用问题"><a href="#12-redis应用问题" class="headerlink" title="12 redis应用问题"></a>12 redis应用问题</h2><h3 id="12-1-缓存穿透"><a href="#12-1-缓存穿透" class="headerlink" title="12.1 缓存穿透"></a>12.1 缓存穿透</h3><h4 id="12-1-1-问题描述"><a href="#12-1-1-问题描述" class="headerlink" title="12.1.1 问题描述"></a>12.1.1 问题描述</h4><p>key对应的数据在数据库并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据库。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><p><img src="20221009192353.png" style="zoom:70%"></p><h4 id="12-1-2-解决方案"><a href="#12-1-2-解决方案" class="headerlink" title="12.1.2 解决方案"></a>12.1.2 解决方案</h4><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><p>解决方案：</p><p>（1）  <strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</p><p>（2）  <strong>设置可访问的名单（白名单）：</strong></p><p>使用bitmap类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p><p>（3）  <strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p><p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p><p><strong>（4）</strong>  <strong>进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p><h3 id="12-2-缓存击穿"><a href="#12-2-缓存击穿" class="headerlink" title="12.2 缓存击穿"></a>12.2 缓存击穿</h3><h4 id="12-2-1-问题描述"><a href="#12-2-1-问题描述" class="headerlink" title="12.2.1 问题描述"></a>12.2.1 问题描述</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p><img src="20221009200327.png" style="zoom:80%"></p><h4 id="12-2-2-解决方案"><a href="#12-2-2-解决方案" class="headerlink" title="12.2.2 解决方案"></a>12.2.2 解决方案</h4><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p><p>解决问题：</p><p><strong>（1）预先设置热门数据：</strong>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p><p><strong>（2）实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长</p><p><strong>（3）使用锁：</strong></p><p>​        （3.1）  就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</p><p>​        （3.2）  先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</p><p>​        （3.3）  当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</p><p>​        （3.4）  当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</p><p><img src="20221009200704.png" style="zoom:80%"></p><h3 id="12-3-缓存雪崩"><a href="#12-3-缓存雪崩" class="headerlink" title="12.3 缓存雪崩"></a>12.3 缓存雪崩</h3><h4 id="12-3-1-问题描述"><a href="#12-3-1-问题描述" class="headerlink" title="12.3.1 问题描述"></a>12.3.1 问题描述</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key。</p><h4 id="12-3-2-解决方案"><a href="#12-3-2-解决方案" class="headerlink" title="12.3.2 解决方案"></a>12.3.2 解决方案</h4><ul><li><strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）</li><li><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p></li><li><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></li><li><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p></li></ul><h3 id="12-4-分布式锁"><a href="#12-4-分布式锁" class="headerlink" title="12.4 分布式锁"></a>12.4 分布式锁</h3><h4 id="12-4-1-分布式锁简介"><a href="#12-4-1-分布式锁简介" class="headerlink" title="12.4.1 分布式锁简介"></a>12.4.1 分布式锁简介</h4><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><p>分布式锁主流的实现方案：</p><ol><li><p>基于数据库实现分布式锁</p></li><li><p>基于缓存（Redis等）</p></li><li><p>基于Zookeeper</p></li></ol><p>每一种分布式锁解决方案都有各自的优缺点：</p><ol><li><p>性能：redis最高</p></li><li><p>可靠性：zookeeper最高</p></li></ol><p>这里，我们就基于redis实现分布式锁。</p><h4 id="12-4-2-使用redis实现分布式锁的演示"><a href="#12-4-2-使用redis实现分布式锁的演示" class="headerlink" title="12.4.2  使用redis实现分布式锁的演示"></a>12.4.2  使用redis实现分布式锁的演示</h4><p>使用setnx命令实现分布式锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; setnx user 10  # 设置成功 并且上锁了<br>(integer) 1<br>127.0.0.1:6379&gt; setnx user 20  # 设置不成功，因为锁没有释放 <br>(integer) 0<br>127.0.0.1:6379&gt; setnx user 30<br>(integer) 0<br>127.0.0.1:6379&gt; del user  # 释放锁<br>(integer) 1<br>127.0.0.1:6379&gt; setnx user 20  # 释放锁成功<br>(integer) 1<br><br></code></pre></td></tr></table></figure><p>那这种实现方式有没有什么问题?现在上锁之后，锁都是我们程序员手动释放的。如果我们因为一些原因没有释放锁，那锁就会一直存在。</p><p>解决这个问题的方案很简单，就是上锁以后，我们给锁设置一个过期时间，当时间到了之后，锁就自动释放。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; setnx user 10  # 设置锁<br>(integer) 1<br>127.0.0.1:6379&gt; expire user 20  # 设置锁的过期时间 20秒<br>(integer) 1<br>127.0.0.1:6379&gt; setnx user 20<br>(integer) 0<br>127.0.0.1:6379&gt; ttl user<br>(integer) 12<br>127.0.0.1:6379&gt; setnx user 5  # 锁没有过期 所以设置值失败<br>(integer) 0<br>127.0.0.1:6379&gt; setnx user 5  # 锁过期了，所以值设置成功<br>(integer) 1<br></code></pre></td></tr></table></figure><p>现在我们设置锁，并且设置锁的失效时间是由两个命令实现的。并不具备原子性。如果上锁成功，还没来得及设置锁的过期时间，redis服务就挂掉了，那锁的失效时间还是没有设置成功，如何解决?</p><p>我们可以在上锁的同时设置过期时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set user 10 nx ex 20  # 上锁的同时 设置过期时间是20<br>OK<br>127.0.0.1:6379&gt; ttl user<br>(integer) 17<br>127.0.0.1:6379&gt; setnx user 20  # 锁没有释放 设置值失败<br>(integer) 0<br>127.0.0.1:6379&gt; setnx user 18<br>(integer) 0<br>127.0.0.1:6379&gt; ttl user<br>(integer) 7<br>127.0.0.1:6379&gt; setnx user 10 # 锁释放 设置值成功<br>(integer) 1<br></code></pre></td></tr></table></figure><h4 id="12-4-3-使用java代码实现分布式锁"><a href="#12-4-3-使用java代码实现分布式锁" class="headerlink" title="12.4.3 使用java代码实现分布式锁"></a>12.4.3 使用java代码实现分布式锁</h4><ul><li>前期准备工作：</li></ul><p>在redis里面设置num = 0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set num 0<br></code></pre></td></tr></table></figure><p>在redis里面安装ab工具，用来并发测试我们的请求。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[qgc@qgc-virtual-machine]~$ </span><span class="language-bash">yum install httpd-tools</span><br></code></pre></td></tr></table></figure><ul><li>编写java代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;testLock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLock</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//1获取锁</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>);<span class="hljs-comment">//setnx lock 111</span><br>    /<span class="hljs-number">2</span>获取锁成功、查询num的值<br>    <span class="hljs-keyword">if</span>(lock)&#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;num&quot;</span>);<br>        /<span class="hljs-number">2.1</span>判断num为空<span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(value))&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        /<span class="hljs-number">2.2</span>有值就转成成<span class="hljs-type">int</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(value+<span class="hljs-string">&quot;&quot;</span>);<br>        /<span class="hljs-number">2.3</span>把redis的num加<span class="hljs-number">1</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;num&quot;</span>, ++num);<br>        /<span class="hljs-number">2.4</span>释放锁，del<br>        redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//3获取锁失败、每隔0.1秒再获取</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>            testLock();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在linux里面执行下面请求：</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">ab -n 1000 -c 100 http://192.168.1.3:8080/redisTest/testLock<br>1000: 1000次请求<br>100: 每次请求的并发数是100<br>192.168.1.3  本机的ip地址<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[qgc@qgc-virtual-machine]~$ </span><span class="language-bash">ab -n 1000 -c 100 http://192.168.1.3:8080/redisTest/testLock</span><br></code></pre></td></tr></table></figure><p>执行完毕，查看num的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; get num<br>&quot;1000&quot;  # 演示出了分布式锁的效果<br></code></pre></td></tr></table></figure><p><strong>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放。</strong></p><p><strong>解决：设置过期时间，自动释放锁。</strong></p><p><img src="20221009221846.png"></p><p>压力测试肯定也没有问题。</p><p><strong>问题：锁存在被误删的情况</strong></p><p><img src="20221009222539.png" style="zoom:70%"></p><p><strong>解决方案：使用UUID防止误删</strong></p><p>每次释放锁操作的时候，都拿到当前的uuid和锁的uuid进行比对，如果一致才允许释放锁。</p><p><img src="20221009223003.png"></p><p><strong>问题：锁删除操作不具备原子性！！！</strong></p><h4 id="12-4-4-使用lua脚本保证锁删除的原子性"><a href="#12-4-4-使用lua脚本保证锁删除的原子性" class="headerlink" title="12.4.4 使用lua脚本保证锁删除的原子性"></a>12.4.4 使用lua脚本保证锁删除的原子性</h4><p>由于锁删除操作不具备原子性，还是会出现锁的误删操作。</p><p><img src="20221009231238.png" style="zoom:80%"></p><p><strong>解决方案：使用lua脚本优化代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;testLockLua&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLockLua</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>    /<span class="hljs-number">2</span> 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！<br>    <span class="hljs-comment">// 3 获取锁</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, uuid, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>    <span class="hljs-comment">// 如果true</span><br>    <span class="hljs-keyword">if</span> (lock) &#123;<br>        <span class="hljs-comment">// 执行的业务逻辑开始</span><br>        <span class="hljs-comment">// 获取缓存中的num 数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;num&quot;</span>);<br>        <span class="hljs-comment">// 如果是空直接返回</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(value)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(value + <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 使num 每次+1 放入缓存</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;num&quot;</span>, ++num);<br>        <span class="hljs-comment">/*使用lua脚本来锁*/</span><br>        <span class="hljs-comment">// 定义lua 脚本</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;<br>        <span class="hljs-comment">// 使用redis执行lua执行</span><br>        DefaultRedisScript&lt;Long&gt; redisScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        redisScript.setScriptText(script);<br>        <span class="hljs-comment">// 设置一下返回值类型 为Long</span><br>        <span class="hljs-comment">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span><br>        <span class="hljs-comment">// 那么返回字符串与0 会有发生错误。</span><br>        redisScript.setResultType(Long.class);<br>        <span class="hljs-comment">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span><br>        redisTemplate.execute(redisScript, Arrays.asList(<span class="hljs-string">&quot;lock&quot;</span>), uuid);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 其他线程等待</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 睡眠</span><br>            Thread.sleep(<span class="hljs-number">100</span>);<br>            <span class="hljs-comment">// 睡醒了之后，调用方法。</span><br>            testLockLua();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><ul><li><p><strong>互斥性。在任意时刻，只有一个客户端能持有锁。</strong></p></li><li><p><strong>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</strong></p></li><li><p><strong>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</strong></p></li><li><p><strong>加锁和解锁必须具有原子性。</strong></p></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Java知识体系</category>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接雨水Ⅱ</title>
    <link href="/2023/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A1/"/>
    <url>/2023/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="接雨水Ⅱ"><a href="#接雨水Ⅱ" class="headerlink" title="接雨水Ⅱ"></a>接雨水Ⅱ</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原题链接：<a href="https://leetcode.cn/problems/trapping-rain-water-ii/">407. 接雨水 II - 力扣（LeetCode）</a></p><p>给你一个 <code>m x n</code> 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p><p><strong>示例 1:</strong></p><p><img src="/2023/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A1/image-20230704221722330.png" alt="image-20230704221722330"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: heightMap = <span class="hljs-string">[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</span><br>输出: <span class="hljs-number">4</span><br>解释: 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">1</span>=<span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="/2023/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A1/image-20230704221752364.png" alt="image-20230704221752364"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: heightMap = <span class="hljs-comment">[<span class="hljs-comment">[3,3,3,3,3]</span>,<span class="hljs-comment">[3,2,2,2,3]</span>,<span class="hljs-comment">[3,2,1,2,3]</span>,<span class="hljs-comment">[3,2,2,2,3]</span>,<span class="hljs-comment">[3,3,3,3,3]</span>]</span><br>输出: 10<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>m == heightMap.length</code></li><li><code>n == heightMap[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 104</code></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>参考接<a href="https://qgcatg.top/2023/07/03/%E6%8E%A5%E9%9B%A8%E6%B0%B4/#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">接雨水 - 子川个人博客 (qgcatg.top)</a>中的堆解法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trapRainWater</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heightMap)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heightMap.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> heightMap[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 优先队列(位置， 高度)</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a[<span class="hljs-number">2</span>]-b[<span class="hljs-number">2</span>]);<br>        <span class="hljs-type">boolean</span>[][] si = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n+<span class="hljs-number">10</span>][m+<span class="hljs-number">10</span>];<br>        <span class="hljs-comment">// 初态为heightMap的四周的元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span> || j==<span class="hljs-number">0</span> || i == n-<span class="hljs-number">1</span> || j==m-<span class="hljs-number">1</span>)&#123;<br>                    pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i,j,heightMap[i][j]&#125;);<br>                    si[i][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] xx = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">int</span>[] yy = &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!pq.isEmpty())&#123;<br>            <span class="hljs-comment">// 取出第一个元素</span><br>            <span class="hljs-type">int</span>[] tmp = pq.poll();<br>            <span class="hljs-comment">// 看看四周</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> tmp[<span class="hljs-number">0</span>] + xx[i], y = tmp[<span class="hljs-number">1</span>] + yy[i];<br>                <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m &amp;&amp; !si[x][y])&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">tmp_s</span> <span class="hljs-operator">=</span> heightMap[x][y];<br>                    <span class="hljs-keyword">if</span>(tmp_s &lt; tmp[<span class="hljs-number">2</span>])&#123;<br>                        ans += tmp[<span class="hljs-number">2</span>] - tmp_s;<br>                    &#125;<br>                    pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, y, Math.max(tmp_s, tmp[<span class="hljs-number">2</span>])&#125;);<br>                    si[x][y] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>堆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接雨水</title>
    <link href="/2023/07/03/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2023/07/03/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原题链接：<a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水 - 力扣（LeetCode）</a></p><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="/2023/07/03/%E6%8E%A5%E9%9B%A8%E6%B0%B4/image-20230703085843447.png" alt="image-20230703085843447"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>n == height.length</code></p></li><li><p><code>1 &lt;= n &lt;= 2 * 104</code></p></li><li><p><code>0 &lt;= height[i] &lt;= 105</code></p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>三种思路：</p><ol><li><p>按列思考（纯暴力），思考每一列可以接多少雨水；</p><p>具体实现思路，从第二列开始向左找最高的柱子并记录高度tmp_l，并且向右找最高的柱子记录高度tmp_r，记录当前列柱子高度为tmp，那么当前列接雨水的数量ans&#x3D;min(tmp_l，tmp_r) - tmp;</p></li><li><p>按行（栈）思考，匹配两个柱子之间所占行的雨水数；</p></li><li><p>dp优化方法1，定义集合f_l[i]代表第 i 列左边最高的墙的高度，f_r[i]代表第 i列右边最高的墙的高度，构建如上集合后，用法1解。</p><p>状态转移方程：</p><ul><li>f_l[i] &#x3D; max(f_l[i-1], height[i-1])</li><li>f_r[i] &#x3D; max(f_r[i+1], height[i+1])</li></ul></li><li><p>堆思路（木桶效应）：</p><p>我们可以先让两边的端点入堆，然后弹出较小者，并检查其左（或右）的高度是否比它小，如果比它小，说明可以注水，那么，我们就把它注水到相同的高度，并将注水后的高度入堆，如果比它高，直接入堆，依次进行下去，最终，总的注水量就是接雨水的量。</p><p>当然，这里为了防止重复访问每个坐标，我们使用一个 si 变量记录已经访问过的坐标。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>纯暴力</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> height[i], tmp_l = tmp, tmp_r = tmp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> ; j--)&#123;<br>                <span class="hljs-keyword">if</span>(tmp_l &lt;= height[j])&#123;<br>                    tmp_l = height[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(tmp_r &lt;= height[j])&#123;<br>                    tmp_r = height[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(tmp &lt;= tmp_l &amp;&amp; tmp &lt;= tmp_r)ans += Math.min(tmp_l, tmp_r) - tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录：</p><p><img src="/2023/07/03/%E6%8E%A5%E9%9B%A8%E6%B0%B4/image-20230703090848027.png" alt="image-20230703090848027"></p><p>可以看出来，暴力的效率很差。</p><ol start="2"><li>按行思考，考虑用栈来处理，入栈策略为：</li></ol><ul><li>当前高度小于等于栈顶高度，入栈，指针后移。</li><li>当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复当前的步骤。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 柱子的数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-comment">// 雨水的数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        s.push(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp_r</span> <span class="hljs-operator">=</span> height[i], tmp_s = height[(<span class="hljs-type">int</span>)s.peek()];<br>            <span class="hljs-keyword">while</span>(tmp_r &gt; tmp_s &amp;&amp; !s.empty())&#123;<br>                s.pop();<br>                <span class="hljs-keyword">if</span>(s.empty())<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)s.peek();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp_l</span> <span class="hljs-operator">=</span> height[j];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> i - j - <span class="hljs-number">1</span>;<br>                ans += (Math.min(tmp_l, tmp_r) - tmp_s) * d;<br>                tmp_s = tmp_l;<br><br>            &#125;<br>            s.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录：</p><p><img src="/2023/07/03/%E6%8E%A5%E9%9B%A8%E6%B0%B4/image-20230703214102148.png" alt="image-20230703214102148"></p><p>这种方法快了很多嘿嘿嘿。</p><ol start="3"><li>dp优化方法1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 柱子的数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] f_l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span>[] f_r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            f_l[i] = Math.max(f_l[i-<span class="hljs-number">1</span>], height[i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            f_r[i] = Math.max(f_r[i+<span class="hljs-number">1</span>], height[i+<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(f_l[i], f_r[i]);<br>            <span class="hljs-keyword">if</span>(min &gt; height[i])<br>            ans += min - height[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录：</p><p><img src="/2023/07/03/%E6%8E%A5%E9%9B%A8%E6%B0%B4/image-20230703215921047.png" alt="image-20230703215921047"></p><p>比栈还要快！！！</p><p>众所周知，dp可以用滚动数组优化，但是这里有两个dp，我们选择优化其中一个，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 柱子的数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">f_l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] f_r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            f_r[i] = Math.max(f_r[i+<span class="hljs-number">1</span>], height[i+<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 优化了左边最大值的寻找</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            f_l = Math.max(f_l, height[i-<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(f_l, f_r[i]);<br>            <span class="hljs-keyword">if</span>(min &gt; height[i])<br>            ans += min - height[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录：</p><p><img src="/2023/07/03/%E6%8E%A5%E9%9B%A8%E6%B0%B4/image-20230703220615238.png" alt="image-20230703220615238"></p><p>感觉效率没什么变化。</p><ol start="4"><li>堆：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-type">int</span>[] dirs = &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 用优先队列解决，保存&lt;位置,高度&gt;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">boolean</span>[] si = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        si[<span class="hljs-number">0</span>] = si[n - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 上述语句在Java中创建了一个优先队列（PriorityQueue）的实例对象，该优先队列按照传入的比较器（Comparator）来确定元素的优先级。比较器使用了lambda表达式 (a, b) -&gt; a[1] - b[1]，表示比较元素数组的索引为1的元素的大小。元素类型为int数组（int[]）。</span><br><br>        <span class="hljs-comment">// 换句话说，这个优先队列会根据int数组中索引为1的元素的大小来确定元素的优先级，其中较小的元素会被放置在队列的前面。</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a[<span class="hljs-number">1</span>]-b[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 初态把第一个元素和最后一个元素放进去</span><br>        heap.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">0</span>, height[<span class="hljs-number">0</span>]&#125;);<br>        heap.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;n - <span class="hljs-number">1</span>, height[n - <span class="hljs-number">1</span>]&#125;);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;<br>            <span class="hljs-comment">// 取出当前最小的柱子的下标并出队</span><br>            <span class="hljs-type">int</span>[] element = heap.poll();<br>            <span class="hljs-comment">// 看看左右两边的情况</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> element[<span class="hljs-number">0</span>] + dir;<br>                <span class="hljs-keyword">if</span> (pos &gt;= <span class="hljs-number">0</span> &amp;&amp; pos &lt; n &amp;&amp; !si[pos]) &#123;<br>                    <span class="hljs-comment">// 如果当前高度左或右的高度小于当前高度</span><br>                    <span class="hljs-keyword">if</span> (height[pos] &lt; element[<span class="hljs-number">1</span>]) &#123;<br>                        <span class="hljs-comment">// 计算左或右列的水量</span><br>                        ans += element[<span class="hljs-number">1</span>] - height[pos];<br>                    &#125;<br>                    <span class="hljs-comment">// 比较当前和左或者右列的高度，并让最大高度与当前位置入队</span><br>                    heap.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;pos, Math.max(height[pos], element[<span class="hljs-number">1</span>])&#125;);<br>                    <span class="hljs-comment">// 标记位置</span><br>                    si[pos] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>AC记录：</p><p><img src="/2023/07/03/%E6%8E%A5%E9%9B%A8%E6%B0%B4/image-20230704214748751.png" alt="image-20230704214748751"></p><p>emm，至此此题结束啦！！！(&gt;.&lt;完结撒花)</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>dp</category>
      
      <category>堆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>dp</tag>
      
      <tag>暴力</tag>
      
      <tag>栈</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三角形最小路径和</title>
    <link href="/2023/07/02/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2023/07/02/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原题链接：<a href="https://leetcode.cn/problems/triangle/">120. 三角形最小路径和 - 力扣（LeetCode）</a></p><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br> <span class="hljs-number"> 3 </span>4<br><span class="hljs-number"> 6 </span>5 7<br>4<span class="hljs-number"> 1 </span>8 3<br>自顶向下的最小路径和为 11（即，2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 1 </span>= 11）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：triangle = <span class="hljs-string">[[-10]]</span><br>输出：<span class="hljs-number">-10</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= triangle.length &lt;= 200</code></li><li><code>triangle[0].length == 1</code></li><li><code>triangle[i].length == triangle[i - 1].length + 1</code></li><li><code>-104 &lt;= triangle[i][j] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你可以只使用 <code>O(n)</code> 的额外空间（<code>n</code> 为三角形的总行数）来解决这个问题吗？</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两种思路：</p><p>1.自底向上：定义集合f[i] [j]为从下到上走到当前路径的最小路径和 </p><p>状态转移方程:f[i] [j] &#x3D;  min(f[i+1] [j], f[i+1] [j+1]) + triangle[i-1] [j-1]</p><p>初态：f[0<del>i] [0</del>j] &#x3D; 0</p><p>2.自顶向下：定义集合f[i] [j]为从上到下走到当前路径的最小路径和 </p><p>状态转移方程：f[i] [j] &#x3D;  min(f[i-1] [j], f[i-1] [j+1]) + triangle[i-1] [j-1]</p><p>初态：f[0<del>i] [0</del>j] &#x3D; MAX</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>自底向上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> triangle.get(n-<span class="hljs-number">1</span>).size();<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">10</span>][m+<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt;= <span class="hljs-number">1</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> triangle.get(i-<span class="hljs-number">1</span>).get(j-<span class="hljs-number">1</span>);<br>                f[i][j] = Math.min(f[i+<span class="hljs-number">1</span>][j], f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) + tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录：</p><p><img src="/2023/07/02/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/image-20230702090929428.png" alt="image-20230702090929428"></p><p>自顶向下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> triangle.get(n-<span class="hljs-number">1</span>).size();<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">10</span>][m+<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> triangle.get(i-<span class="hljs-number">1</span>).get(j-<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>)<br>                f[i][j] = f[i-<span class="hljs-number">1</span>][j] + tmp;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == i)<br>                f[i][j] = f[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + tmp; <br>                <span class="hljs-keyword">else</span><br>                f[i][j] = Math.min(f[i-<span class="hljs-number">1</span>][j], f[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]) + tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">10008</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            ans = Math.min(ans, f[n][i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录：</p><p><img src="/2023/07/02/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/image-20230702090913528.png" alt="image-20230702090913528"></p><p>从AC记录上看两种代码效率差不多，可是自顶向下的要代码书写要复杂一些，所以说代码优化我们只选取自底向上来优化（自顶向下的优化也差不多）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> triangle.get(n-<span class="hljs-number">1</span>).size();<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt;= <span class="hljs-number">1</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> triangle.get(i-<span class="hljs-number">1</span>).get(j-<span class="hljs-number">1</span>);<br>                f[j] = Math.min(f[j], f[j+<span class="hljs-number">1</span>]) + tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录</p><p><img src="/2023/07/02/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/image-20230702091245843.png" alt="image-20230702091245843"></p><p>至此此题完毕。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不同路径Ⅱ</title>
    <link href="/2023/07/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/"/>
    <url>/2023/07/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="不同路径Ⅱ"><a href="#不同路径Ⅱ" class="headerlink" title="不同路径Ⅱ"></a>不同路径Ⅱ</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原题链接：<a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II - 力扣（LeetCode）</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><strong>示例 1：</strong></p><p><img src="/2023/07/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/image-20230701125340246.png" alt="image-20230701125340246"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：obstacleGrid = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">3</span>x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 <span class="hljs-number">2</span> 条不同的路径：<br><span class="hljs-number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2023/07/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/image-20230701125415503.png" alt="image-20230701125415503"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：obstacleGrid = <span class="hljs-string">[[0,1],[0,0]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看注释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-comment">// 相较于&quot;不同路径&quot;多了个判断</span><br>        <span class="hljs-comment">// 即判断是否是障碍物</span><br><br><br>        <span class="hljs-comment">// 集合f[i][j]定义为走到坐标(i,j)时的方案数</span><br>        <span class="hljs-comment">// 状态转移方程：</span><br>        <span class="hljs-comment">// f[i][j] = f[i-1][j] + f[i][j-1]</span><br>        <span class="hljs-comment">// 及从上面走过来的方案数和从左边走过来的方案数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid.length, m = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">10</span>][m + <span class="hljs-number">10</span>];<br>        <span class="hljs-comment">// 初态</span><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>)&#123;<br>                    f[i][j] = f[i-<span class="hljs-number">1</span>][j] + f[i][j-<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    f[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>AC提交</p><p><img src="/2023/07/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/image-20230701125523708.png" alt="image-20230701125523708"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小路径和</title>
    <link href="/2023/07/01/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2023/07/01/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原题链接：<a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和 - 力扣（LeetCode）</a></p><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p><strong>示例 1:</strong></p><p> <img src="/2023/07/01/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/image-20230701103943915.png" alt="image-20230701103943915"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 200</code></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>定义集合f[i] [j]为到达(i, j )位置时的最小数字和</p><p>状态转移方程：f[i] [j] &#x3D; min(f[i-1] [j], f[i] [j-1]) + gird[i-1] [j-1]</p><p>边界问题：防止不越界就可以</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[i].length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)<br>                    grid[i][j] = grid[i][j-<span class="hljs-number">1</span>] + grid[i][j];<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)<br>                    grid[i][j] = grid[i-<span class="hljs-number">1</span>][j] + grid[i][j];<br>                <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span> &amp;&amp; j != <span class="hljs-number">0</span>)<br>                    grid[i][j] = Math.min(grid[i-<span class="hljs-number">1</span>][j], grid[i][j-<span class="hljs-number">1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> grid[grid.length - <span class="hljs-number">1</span>][grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录：</p><p><img src="/2023/07/01/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/image-20230701110533363.png" alt="image-20230701110533363"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不同路径</title>
    <link href="/2023/07/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/07/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原题链接：<a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径 - 力扣（LeetCode）</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="/2023/07/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/image-20230701104010735.png" alt="image-20230701104010735"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<br><br><span class="hljs-number">1.</span> 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右<br><span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向下<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">7</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">28</span><br>示例 <span class="hljs-number">4</span>：<br><br>输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 2 * 10^9^</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>代码里有注释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 集合f[i][j]定义为走到坐标(i,j)时的方案数</span><br>        <span class="hljs-comment">// 状态转移方程：</span><br>        <span class="hljs-comment">// f[i][j] = f[i-1][j] + f[i][j-1]</span><br>        <span class="hljs-comment">// 及从上面走过来的方案数和从左边走过来的方案数</span><br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">10</span>][m + <span class="hljs-number">10</span>];<br>        <span class="hljs-comment">// 初态</span><br>        f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                f[i][j] = f[i-<span class="hljs-number">1</span>][j] + f[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n][m];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录：</p><p><img src="/2023/07/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/image-20230701103615379.png" alt="image-20230701103615379"></p><p>滚动数组优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 滚动数组</span><br>        <span class="hljs-comment">// 下一次的值和两个值有关，即f[i-1][j] 和f[i][j-1]</span><br>        <span class="hljs-comment">// 每次保留这两个值即可.</span><br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">10</span>];<br>        Arrays.fill(f, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>                f[j] = f[j] + f[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录</p><p><img src="/2023/07/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/image-20230701103703231.png" alt="image-20230701103703231"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除并获得点数</title>
    <link href="/2023/06/29/%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/"/>
    <url>/2023/06/29/%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="删除并获得点数"><a href="#删除并获得点数" class="headerlink" title="删除并获得点数"></a>删除并获得点数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原题链接：<a href="https://leetcode.cn/problems/delete-and-earn/">740. 删除并获得点数 - 力扣（LeetCode）</a></p><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p><p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [3,4,2]<br>输出：6<br>解释：<br>删除 4 获得 4 个点数，因此 3 也被删除。<br>之后，删除 2 获得 2 个点数。总共获得 6 个点数。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [2,2,3,3,3,4]<br>输出：9<br>解释：<br>删除 3 获得 3 个点数，接着要删除两个 2 和 4 。<br>之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。<br>总共获得 9 个点数。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>定义集合f[i]：选取值为1~i的数可以获取的最大值</p><p>​    状态转移方程：</p><p>​    f[i] &#x3D; max(f[i-1], f[i-2] + f[i] * i)</p><p>​    含义是</p><p>​    1. 如果选取i值那么最终结果就是f[i-2] (选取值为1~(i-2)的数可以获取的最大值)和当前值相加</p><p>​    2. 如果不选就是选取值为1<del>i的数可以获取的最大值与选取值为1</del>(i-1)的数可以获取的最大值想的</p><p>​    3. f[i]的结果是1和2的中的最大值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteAndEarn</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 数值的最大范围</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e4</span>);<br>        <span class="hljs-comment">// 定义集合f[i]：选取值为1~i的数可以获取的最大值</span><br>        <span class="hljs-comment">// 状态转移方程：</span><br>        <span class="hljs-comment">// f[i] = max(f[i-1], f[i-2] + f[i] * i)</span><br>        <span class="hljs-comment">// 含义是</span><br>        <span class="hljs-comment">// 1.如果选取i值那么最终结果就是之前f[i-2](选取值为1~(i-2)的数可以获取的最大值)和当前值相加</span><br>        <span class="hljs-comment">// 2.如果不选就是选取值为1~i的数可以获取的最大值与选取值为1~(i-1)的数可以获取的最大值想的</span><br>        <span class="hljs-comment">// 3.f[i]的结果是1和2的中的最大值</span><br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">10</span>];<br>        Arrays.fill(f, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 初态为值为i的数字的个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            f[nums[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            f[i] = Math.max(f[i - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">2</span>] + f[i] * i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录</p><p><img src="/2023/06/29/%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/image-20230629214933734.png" alt="image-20230629214933734"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打家劫舍</title>
    <link href="/2023/06/28/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2023/06/28/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原题链接：<a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍 - 力扣（LeetCode）</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。<br></code></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>定义集合f（i）为偷i个房子的最高金额，那么就有如下状态转移方程：</p><p>$$<br>f(i) &#x3D; max(f(i-1) , f(i-2) + nums[i])<br>$$<br>指的是对于当前偷i个房子的最高金额可以理解为：</p><ol><li><p>偷前1~i-1个房子的最高金额f(i-1)</p></li><li><p>偷1~(i-2)个房子的最高金额和当前房子的金额之和</p></li><li><p>取1和2的最大值即为f(i)</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>按上述思路代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 表示偷i个房子时的金额最大数</span><br>        <span class="hljs-comment">// 状态转移方程</span><br>        <span class="hljs-comment">// dp[i] = max(dp[i-1], dp[i-1] + nums[i])</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">105</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 初态偷0和1个房子时的金额最大数</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录</p><p><img src="/image-20230629114538555.png" alt="image-20230629114538555"></p><p>空间优化（滚动数组）代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 空间优化</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Math.max(a + nums[i - <span class="hljs-number">1</span>], b);<br>            a = b;<br>            b = ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录：</p><p><img src="/image-20230629114712134.png" alt="image-20230629114712134"></p><p>很离谱的是内存消耗增加了。。。。。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理概述</title>
    <link href="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理概述"><a href="#编译原理概述" class="headerlink" title="编译原理概述"></a>编译原理概述</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><blockquote class="pullquote mindmap mindmap-md"><ul><li>编译原理入门<ul><li>基本概念<ul><li>机器语言</li><li>汇编语言</li><li>高级语言</li></ul></li><li>编译器结构<ul><li>词法分析器</li><li>语法分析器</li><li>语义分析器</li><li>中间代码生成</li><li>机器无关代码优化器</li><li>目标代码生成器</li><li>机器相关代码优化器</li></ul></li></ul></li></ul></blockquote><blockquote class="pullquote mindmap mindmap-md"><ul><li>程序运行时的逻辑存储空间<ul><li>代码区</li><li>数据区<ul><li>静态数据区（全局数据区）</li><li>动态数据区<ul><li>堆区</li><li>栈区</li></ul></li><li>分配规则<ul><li>动态存储分配<ul><li>堆式存储分配</li><li>栈式存储分配</li></ul></li><li>静态存储分配</li></ul></li></ul></li></ul></li></ul></blockquote><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li><p><strong>编译逻辑过程</strong></p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627195504669.png" alt="image-20230627195504669"></li></ul></li><li><p><strong>语法</strong></p><ul><li><p><strong>合法的程序（语言的合法性），定义什么样的符号系列是合法的。主要侧重结构是否完整。</strong></p></li><li><p><strong>如：</strong>  <strong>A：&#x3D;B+C</strong> <strong>（编译时，语法正确）</strong>   </p><p>​           <strong>A</strong> <strong>：&#x3D;</strong> <strong>B+</strong> <strong>（编译时，语法错误）</strong><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627200201184.png" alt="image-20230627200201184"><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627200208243.png" alt="image-20230627200208243"></p></li></ul></li><li><p><strong>符号串</strong></p><ul><li><p><strong>字母表中的符号组成的任意有穷系列。</strong></p></li><li><p><strong>字符的运算</strong></p><p>​<img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627214359573.png" alt="image-20230627214359573"></p></li></ul></li><li><p><strong>符号串特性</strong></p><ul><li><p><strong>顺序：ab与ba不同</strong></p></li><li><p><strong>长度</strong></p></li><li><p>eg：</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627201746982.png" alt="image-20230627201746982"></p></li></ul></li><li><p><strong>头尾</strong></p><ul><li>前后缀</li></ul></li><li><p><strong>固有头</strong></p><ul><li>真前缀</li></ul></li><li><p><strong>固有尾</strong></p><ul><li>真后缀</li></ul></li><li><p>eg：</p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627202458522.png" alt="image-20230627202458522"></li></ul></li><li><p><strong>乘积</strong></p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627202630257.png" alt="image-20230627202630257"></li></ul></li><li><p><strong>连接</strong></p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627202728717.png" alt="image-20230627202728717"></li></ul></li><li><p><strong>幂</strong></p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627202833321.png" alt="image-20230627202833321"></li></ul></li><li><p><strong>字母表的闭包：字母表中字符形成的有穷长的串的集合</strong></p><ul><li><strong>正闭包</strong><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627202944938.png" alt="image-20230627202944938"></li></ul></li><li><strong>克林闭包</strong><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627202951900.png" alt="image-20230627202951900"></li></ul></li></ul></li><li><p><strong>规则</strong></p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627203123487.png" alt="image-20230627203123487"></li></ul></li><li><p><strong>文法</strong></p><ul><li><p><strong>语言描述规则，用来定义句子的结构，用有限的规则把语言的全部句子描述出来，是以有穷的集合刻划无穷的集合的工具。</strong></p></li><li><p><strong>以一种形式（文法）给出无穷多句子的有穷表达；</strong></p></li><li><p>eg：</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627201328393.png" alt="image-20230627201328393"></p></li></ul></li><li><p><strong>文法的表示</strong></p><ul><li><p><strong>四元组形式</strong></p><ul><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627203319256.png" alt="image-20230627203319256"></p></li><li><p>eg:</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627203622771.png" alt="image-20230627203622771"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627203707079.png" alt="image-20230627203707079"></p></li></ul></li></ul></li><li><p><strong>符号的约定</strong></p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627203942817.png" alt="image-20230627203942817"></li><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627203951898.png" alt="image-20230627203951898"></li></ul></li><li><p><strong>推导</strong></p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627204059286.png" alt="image-20230627204059286"></li><li><strong>直接推导</strong><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627204258181.png" alt="image-20230627204258181"></li></ul></li><li><strong>长度为n的推导（n&gt;0）</strong><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627204421201.png" alt="image-20230627204421201"></li></ul></li><li>eg：<ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627204507097.png" alt="image-20230627204507097"></li></ul></li></ul></li><li><p><strong>句子和句型</strong></p><ul><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627204609040.png" alt="image-20230627204609040"></p></li><li><p><strong>句型的短语</strong></p><ul><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627211352945.png" alt="image-20230627211352945"></p></li><li><p>eg：</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627211528119.png" alt="image-20230627211528119"></p></li></ul></li></ul></li><li><p><strong>语法范畴（非终结符）A的集合</strong>   </p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627204939481.png" alt="image-20230627204939481"></li></ul></li><li><p><strong>文法G生成的语言</strong></p><ul><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627205652849.png" alt="image-20230627205652849"></p></li><li><p>eg：</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627205702929.png" alt="image-20230627205702929"></p></li></ul></li><li><p><strong>文法的等价性</strong></p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627205834895.png" alt="image-20230627205834895"></li></ul></li><li><p><strong>文法的分类</strong></p><ul><li><p><strong>0型文法</strong></p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627210226101.png" alt="image-20230627210226101"></li></ul></li><li><p><strong>1型文法</strong></p><ul><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627210316862.png" alt="image-20230627210316862"></p></li><li><p>eg：</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627210451034.png" alt="image-20230627210451034"></p></li></ul></li><li><p><strong>2型文法</strong></p><ul><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627210557745.png" alt="image-20230627210557745"></p></li><li><p><strong>语法树</strong></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627211005411.png" alt="image-20230627211005411"></p><ul><li><p>eg：</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627211108585.png" alt="image-20230627211108585"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627211128839.png" alt="image-20230627211128839"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627211209979.png" alt="image-20230627211209979"></p></li><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627211256037.png" alt="image-20230627211256037"></p></li></ul></li></ul></li><li><p><strong>3型文法</strong></p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627210739677.png" alt="image-20230627210739677"></li></ul></li><li><p><strong>四种文法之间的关系</strong></p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627210820705.png" alt="image-20230627210820705"></li></ul></li></ul></li><li><p><strong>最左（最右）推导、规范推导</strong> </p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627212135427.png" alt="image-20230627212135427"><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627212045331.png" alt="image-20230627212045331"></li></ul></li><li><p><strong>语法树和推导的作用：</strong> <strong>句型的分析</strong></p><ul><li><p><strong>定义</strong></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627212233112.png" alt="image-20230627212233112"></p></li><li><p>算法分类</p><ul><li>定义</li></ul><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627212451823.png" alt="image-20230627212451823"></p><ul><li><p><strong>自上而下的语法分析</strong></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627212555015.png" alt="image-20230627212555015"></p></li><li><p><strong>自下而上的语法分析</strong></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627212624860.png" alt="image-20230627212624860"></p></li><li><p><strong>句型分析的有关问题</strong></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627212719942.png" alt="image-20230627212719942"></p></li><li><p><strong>自顶向下方法中的主要问题</strong></p><p>​<img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627212855631.png" alt="image-20230627212855631"></p></li><li><p><strong>自底向上方法中的主要问题</strong></p><p>​<img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627212940599.png" alt="image-20230627212940599"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213005733.png" alt="image-20230627213005733"></p></li></ul></li></ul></li><li><p><strong>文法二义性</strong></p><ul><li><p>定义</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213054451.png" alt="image-20230627213054451"></p></li><li><p>eg：</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213121034.png" alt="image-20230627213121034"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213204659.png" alt="image-20230627213204659"></p></li><li><p><strong>消除二义性</strong></p><ul><li>定义</li></ul><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213245208.png" alt="image-20230627213245208"></p><ul><li><p>消除二义性</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627230328641.png" alt="image-20230627230328641"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627230349490.png" alt="image-20230627230349490"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627230415576.png" alt="image-20230627230415576"></p></li></ul></li></ul></li><li><p><strong>文法实用中的一些说明</strong></p><ul><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213318525.png" alt="image-20230627213318525"></p></li><li><p><strong>上下文无关文法中的ε规则</strong>  </p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213435567.png" alt="image-20230627213435567"></p></li><li><p><strong>文法的多余规则</strong></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213516362.png" alt="image-20230627213516362"></p></li></ul></li><li><p><strong>左递归</strong></p><ul><li>定义<ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627230616151.png" alt="image-20230627230616151"></li></ul></li><li>消除左递归<ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627230653150.png" alt="image-20230627230653150"></li><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627230721630.png" alt="image-20230627230721630"></li><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627230737037.png" alt="image-20230627230737037"></li><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627230837598.png" alt="image-20230627230837598"><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627230853497.png" alt="image-20230627230853497"></li></ul></li></ul></li><li>eg<ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627231022047.png" alt="image-20230627231022047"></li></ul></li></ul></li><li><p><strong>正则表达式</strong></p><ul><li><p>定义</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627214216011.png" alt="image-20230627214216011"></p></li><li><p>正则式等价</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627214702074.png" alt="image-20230627214702074"></p></li><li><p><strong>正规式、它所表示的正规语言&#x2F;正规集</strong></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627214507895.png" alt="image-20230627214507895"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627214515579.png" alt="image-20230627214515579"></p></li><li><p>eg</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627214818855.png" alt="image-20230627214818855"><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627214951164.png" alt="image-20230627214951164"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627215102722.png" alt="image-20230627215102722"></p></li><li><p>正则文法和正则式的等价性</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627215220686.png" alt="image-20230627215220686"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627215255245.png" alt="image-20230627215255245"></p></li><li><p>正则文法转正规式</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627220240904.png" alt="image-20230627220240904"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627220230500.png" alt="image-20230627220230500"></p></li><li><p>正则式转正规文法</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627220912100.png" alt="image-20230627220912100"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627221216271.png" alt="image-20230627221216271"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627221337495.png" alt="image-20230627221337495"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627221450601.png" alt="image-20230627221450601"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627221514451.png" alt="image-20230627221514451"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627221618708.png" alt="image-20230627221618708"></p></li></ul></li></ul><h2 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a><strong>有穷自动机</strong></h2><ul><li><p><strong>定义</strong></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627222023086.png" alt="image-20230627222023086"></p></li></ul><h3 id="确定的有穷自动机DFA（Determinstic-Finite-Automata-DFA）"><a href="#确定的有穷自动机DFA（Determinstic-Finite-Automata-DFA）" class="headerlink" title="确定的有穷自动机DFA（Determinstic Finite Automata,DFA）"></a>确定的有穷自动机DFA（Determinstic Finite Automata,DFA）</h3><ul><li><p><strong>定义</strong><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627222222242.png" alt="image-20230627222222242"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627222236877.png" alt="image-20230627222236877"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627222331458.png" alt="image-20230627222331458"></p><ul><li><p>eg</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627222549638.png" alt="image-20230627222549638"></p></li><li><p><strong>DFA状态转换图表示</strong></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627222623277.png" alt="image-20230627222623277"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627222726361.png" alt="image-20230627222726361"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627222755380.png" alt="image-20230627222755380"></p><ul><li><p>eg：</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627223406174.png" alt="image-20230627223406174"></p></li></ul></li></ul></li><li><p><strong>正则式转换为DFA状态转换图</strong></p><ul><li><p>规则和定义</p><ul><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627223556389.png" alt="image-20230627223556389"></p></li><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627223635165.png" alt="image-20230627223635165"></p></li></ul><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627223651793.png" alt="image-20230627223651793"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627223806238.png" alt="image-20230627223806238"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627223754158.png" alt="image-20230627223754158"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627223927057.png" alt="image-20230627223927057"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627223944741.png" alt="image-20230627223944741"></p></li><li><p>正则式转DFA的过程</p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627224149362.png" alt="image-20230627224149362"></li></ul></li><li><p>eg：</p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627224217662.png" alt="image-20230627224217662"></li><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627224228721.png" alt="image-20230627224228721"></li></ul></li><li><p><strong>正则文法 构造DFA状态转换图</strong>  </p><ul><li><p>规则和定义</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627224434939.png" alt="image-20230627224434939"></p></li><li><p>eg：</p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627224528444.png" alt="image-20230627224528444"></p></li></ul></li></ul></li></ul><h2 id="三个重要定义"><a href="#三个重要定义" class="headerlink" title="三个重要定义"></a><strong>三个重要定义</strong></h2><h3 id="首符号集FIRST"><a href="#首符号集FIRST" class="headerlink" title="首符号集FIRST"></a>首符号集FIRST</h3><ul><li><p>定义</p><ul><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627231804522.png" alt="image-20230627231804522"></p></li><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627231949616.png" alt="image-20230627231949616"></p></li><li><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627232031642.png" alt="image-20230627232031642"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627232127218.png" alt="image-20230627232127218"></p></li></ul></li><li><p>eg</p><ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627232726804.png" alt="image-20230627232726804"></li></ul></li></ul><h3 id="后随符号集FOLLOW"><a href="#后随符号集FOLLOW" class="headerlink" title="后随符号集FOLLOW"></a>后随符号集FOLLOW</h3><ul><li>定义<ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627233410038.png" alt="image-20230627233410038"></li><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627233446030.png" alt="image-20230627233446030"></li></ul></li><li>eg<ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627233518786.png" alt="image-20230627233518786"></li><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627233604471.png" alt="image-20230627233604471"></li></ul></li></ul><h3 id="选择集合SELECT-（重要：补充的定义）"><a href="#选择集合SELECT-（重要：补充的定义）" class="headerlink" title="选择集合SELECT  （重要：补充的定义）"></a>选择集合SELECT  （重要：补充的定义）</h3><ul><li>定义<ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627234745692.png" alt="image-20230627234745692"></li><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627234910682.png" alt="image-20230627234910682"></li></ul></li><li>eg<ul><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627235509781.png" alt="image-20230627235509781"></li><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627235714077.png" alt="image-20230627235714077"></li><li><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627235800139.png" alt="image-20230627235800139"></li></ul></li></ul><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213627869.png" alt="image-20230627213627869"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213636743.png" alt="image-20230627213636743"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213643124.png" alt="image-20230627213643124"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213657709.png" alt="image-20230627213657709"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213706449.png" alt="image-20230627213706449"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213717708.png" alt="image-20230627213717708"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213723845.png" alt="image-20230627213723845"></p><p><img src="/2023/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/image-20230627213732063.png" alt="image-20230627213732063"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dp刷题-使用最小花费爬楼梯</title>
    <link href="/2023/06/27/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2023/06/27/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h1><p>原题链接：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：cost = [10,15,20]<br>输出：15<br>解释：你将从下标为 1 的台阶开始。<br>- 支付 15 ，向上爬两个台阶，到达楼梯顶部。<br>总花费为 15 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：cost = [1,100,1,1,1,100,1,1,100,1]<br>输出：6<br>解释：你将从下标为 0 的台阶开始。<br>- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。<br>- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。<br>- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。<br>- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。<br>- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。<br>- 支付 1 ，向上爬一个台阶，到达楼梯顶部。<br>总花费为 6 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= cost.length &lt;= 1000</code></li><li><code>0 &lt;= cost[i] &lt;= 999</code></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>参考爬楼梯，到达n阶的最少费用，一定是n-1和n-2中的最小费用。</p><p>状态转移方程：dp(i) &#x3D; min(dp(i-1),dp(i-2))+cost[i]</p><p>初始状态有:dp[0] &#x3D; cost[0], dp[1] &#x3D; cost[1]</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>按上述解题思路有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>            <span class="hljs-keyword">return</span> a &lt; b ? a : b;<br>        &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br><br>        <span class="hljs-type">int</span> []dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1005</span>];<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cost.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            dp[i] = min(dp[i-<span class="hljs-number">2</span>], dp[i-<span class="hljs-number">1</span>]) + cost[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> min(dp[n-<span class="hljs-number">2</span>], dp[n-<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录如下：</p><p><img src="/2023/06/27/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20230627124218090.png" alt="image-20230627124218090"></p><p>很显然，这个代码可以优化，想了想似乎可以每次必要的值好像就只有俩个，那么dp数组可以省去了（滚动数组），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> cost[<span class="hljs-number">0</span>], b = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cost.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Math.min(a, b) + cost[i];<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(a, b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录如下：</p><p><img src="/2023/06/27/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20230627125507721.png" alt="image-20230627125507721"></p><p>不知道为什么，这个内存消耗只降低了一点点（有大佬解答吗，想知道优化方案），但速度有显著提高。</p><p>至此此题结束啦！！！（&gt;.&lt;撒花)</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dp刷题-爬楼梯</title>
    <link href="/2023/06/26/dp%E5%88%B7%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2023/06/26/dp%E5%88%B7%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原题链接：<a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯 - 力扣（LeetCode）</a></p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3.<span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>每次可以爬一级或者两级，因此最后一次要么是爬了1级，要么是爬了2级，所以问题可以转化为爬上（n-1）级楼梯和爬上（n-2）级楼梯分别有多少种方法，再求两者的和，即：<br>f（x）&#x3D;f（x-1）+f（x-2）；也就是斐波那契数列。</p><p>此题中，base case是：dp[0] &#x3D; 0,dp[1] &#x3D; 1;dp[2]&#x3D;2<br>状态转移方程是：dp[i] &#x3D; dp[i-1] + dp[i-2];</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>状态压缩</strong>，每次只记录必要的数据，即前两个数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录如下：</p><p><img src="/2023/06/26/dp%E5%88%B7%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20230626190019486.png" alt="image-20230626190019486"></p><p>可以看出内存还可以优化，突然想起来两数的替换好像可以不用开辟额外的内存空间，如果我要替换a和b代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a=a+b;<br>b=a-b;<br>a=a-b;<br></code></pre></td></tr></table></figure><p>在此基础上略微修改，我们需要的值是a+b最后在b上，b在a上，如此代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-comment">// 计算这一轮的新值</span><br>            a=a+b;<br>            <span class="hljs-comment">// 替换位置</span><br>            a=a+b;<br>            b=a-b;<br>            a=a-b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录如下：</p><p><img src="/2023/06/26/dp%E5%88%B7%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20230626191222403.png" alt="image-20230626191222403"></p><p>可以看出还可以继续优化（剩下的0.25%是什么魔鬼&gt;&lt;），仔细想想，for循环中的i好像可以优化掉，然后试了一下，内存反倒增加了</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(;n &gt;= <span class="hljs-number">3</span>;n--)&#123;<br>            a=a+b;<br>            a=a+b;<br>            b=a-b;<br>            a=a-b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC记录：</p><p><img src="/2023/06/26/dp%E5%88%B7%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20230626192729974.png" alt="image-20230626192729974"></p><p>内存这个东西好像要靠运气，我多交了几次发现内存有波动。</p><p><img src="/2023/06/26/dp%E5%88%B7%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20230626193229910.png" alt="image-20230626193229910"></p><p>既然这样这题就到这里吧！！！&gt;.&lt;</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习相关概念及其相关算法概述</title>
    <link href="/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一-相关概念"><a href="#一-相关概念" class="headerlink" title="一.相关概念"></a>一.相关概念</h1><h2 id="1-有监督和无监督学习"><a href="#1-有监督和无监督学习" class="headerlink" title="1.有监督和无监督学习"></a>1.<strong>有监督和无监督学习</strong></h2><ul><li>监督学习（有监督学习）是对有标签数据训练数据集进行建模，再用模型对新的数据样本进行分类或者回归分析的机器学习算法。</li><li>无监督学习（非监督式学习）是对没有标签的数据集进行建模，再用模型对新的数据样本进行分类或者回归分析的机器学习算法。</li></ul><p><img src="image-20230626105827119.png" alt="有监督学习"></p><p><img src="image-20230626105731364.png" alt="无监督学习"></p><h2 id="2-分类和回归"><a href="#2-分类和回归" class="headerlink" title="2.分类和回归"></a>2.<strong>分类和回归</strong></h2><ul><li>分类是预测样本属于哪个类别。</li><li>回归是预测样本目标字段的数值。</li></ul><p><img src="image-20230626105647391.png" alt="分类和回归"></p><h2 id="3-数据集和特征"><a href="#3-数据集和特征" class="headerlink" title="3.数据集和特征"></a>3.<strong>数据集和特征</strong></h2><ul><li>数据集是预测系统的原材料，用于训练机器学习模型的历史数据。</li><li>特征是描述数据集中每个样本的属性，有时候也被称为“字段。</li></ul><p><img src="image-20230626105610176.png" alt="猫狗识别案例"></p><h2 id="4-特征工程"><a href="#4-特征工程" class="headerlink" title="4.特征工程"></a>4.<strong>特征工程</strong></h2><ul><li>特征工程是创建预测模型之前的过程，在这个过程中我们将对数据的特征进行分析、清理和结构化。</li></ul><p><img src="image-20230626105924743.png" alt="特征工程"></p><h2 id="5-过拟合与欠拟合"><a href="#5-过拟合与欠拟合" class="headerlink" title="5.过拟合与欠拟合"></a>5.<strong>过拟合与欠拟合</strong></h2><ul><li><p>欠拟合</p><ul><li><p>当机器学习算法无法捕获数据的潜在趋势时，可以看成当模型或算法无法很好地拟合数</p><p>据时，会发生欠拟合。</p></li></ul></li><li><p>过拟合</p><ul><li><p>当数据中存在大量噪声并被机器学习算法捕获时，可以看成当模型或算法对训练数据拟</p><p>合得“太好”时，会发生过拟合。</p></li></ul></li></ul><p><img src="image-20230626110058541.png" alt="过拟合与欠拟合"></p><h1 id="二-线性模型"><a href="#二-线性模型" class="headerlink" title="二.线性模型"></a>二.线性模型</h1><ul><li>概念<ul><li>线性模型并不是指某一种算法，而是一类<strong>算法的统称</strong>。线性模型虽然已经存在了很长时间，但如今仍然是<strong>使用最多的算法之一</strong>。</li></ul></li><li><p>优缺点</p><ul><li>该类算法性能表现优越，即便是在超大型数据集中，训练速度也非常快</li><li>原理易于理解</li></ul></li><li><p><strong>线性模型的基本公式</strong></p><ul><li>线性模型包括线性回归、套索回归、岭回归、逻辑回归和线性支持向量机等。</li><li>线性模型的基本公式如下：</li></ul></li></ul><p><img src="image-20230626111003623.png" alt="线性模型公式"></p><ul><li>eg：<ul><li>假设某个数据集中的样本都只有1个特征，则线性模型可以表示为：ŷ = w·x+b</li><li>如：最后训练出来的特征权重 w=-2，偏差 b= 3，则模型为： <strong>ŷ</strong> <strong>=</strong> <strong>-2x+3</strong></li></ul></li></ul><h1 id="三-决策树算法和随机森林算法"><a href="#三-决策树算法和随机森林算法" class="headerlink" title="三.决策树算法和随机森林算法"></a>三.<strong>决策树算法和随机森林算法</strong></h1><h2 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a><strong>决策树算法</strong></h2><h3 id="决策树算法的特征"><a href="#决策树算法的特征" class="headerlink" title="决策树算法的特征"></a>决策树算法的特征</h3><p>通过对样本特征进行一系列“是”或“否”的判断，进而做出决策。</p><p>例如：家里长辈家孩子要过生日了，送什么礼物呢？</p><p><img src="image-20230626112017416.png" alt=""></p><h3 id="决策树的优势与不足"><a href="#决策树的优势与不足" class="headerlink" title="决策树的优势与不足"></a><strong>决策树的优势与不足</strong></h3><ul><li><p>优势</p><ul><li>可以清晰直观的将其工作过程可视化，可理解性强。</li><li>在训练的过程中对每个特征的处理都是相互独立的，各个特征之间不会相互干扰。</li></ul></li><li><p>不足</p><ul><li>容易出现过拟合问题，max_depth可以解决一定的过拟合问题， 但取值过低又可能造成模型的准确率降低。</li></ul></li></ul><h2 id="随机森林算法"><a href="#随机森林算法" class="headerlink" title="随机森林算法"></a><strong>随机森林算法</strong></h2><h3 id="随机森林与决策树模型的差异"><a href="#随机森林与决策树模型的差异" class="headerlink" title="随机森林与决策树模型的差异"></a>随机森林与决策树模型的差异</h3><p><img src="image-20230626112908489.png" alt="随机森林与决策树模型的差异"></p><h3 id="随机森林的优势与不足"><a href="#随机森林的优势与不足" class="headerlink" title="随机森林的优势与不足"></a><strong>随机森林的优势与不足</strong></h3><ul><li><p>优势</p><ul><li>几乎具有决策树所有的优势，且跟决策树相比，更不容易出现过拟合。</li><li>随机森林支持并行处理。</li></ul></li><li><p>不足</p><ul><li>可视化方面，随机森林不及决策树简单直接。</li><li>对于样本特征非常稀疏的数据来说，随机森林表现往往不如线性模型。</li><li>占用内存较大，训练速度较慢。</li></ul></li></ul><h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a><strong>基本原理</strong></h3><p>支持向量机是一种常见的机器学习算法，用于分类和回归问题。它基于一种将数据映射到高维空间的方法，然后通过寻找最适合分离不同类别的超平面来完成分类。该算法的核心思想是找到能够最大程度地将不同类别数据间隔开的超平面，并在这个超平面上选取一些支持向量来进行分类。在实际应用中，支持向量机在数据维度高、数据量大的情况下表现出色。</p><ul><li>数据集，可以分为线性可分和线性不可分数据集。</li></ul><p><img src="image-20230626113240090.png" alt=""></p><p><img src="image-20230626113315731.png" alt=""></p><h3 id="支持向量机的优势与不足"><a href="#支持向量机的优势与不足" class="headerlink" title="支持向量机的优势与不足"></a><strong>支持向量机的优势与不足</strong></h3><ul><li>优势<ul><li>神经网络走红之前，支持向量机风靡一时，通过gamma参数和c参数的调节，甚至可以生成比较复杂的模型处理复杂的图像问题。</li></ul></li><li>不足<ul><li>性能上，数据集规模大时，比较消耗内存，训练时间长。</li><li>建模过程不如决策树清晰易懂。</li><li>对数据预处理要求较高。</li></ul></li></ul><h2 id="分类模型的评价标准"><a href="#分类模型的评价标准" class="headerlink" title="分类模型的评价标准"></a>分类模型的评价标准</h2><h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p>混淆矩阵是用来总结一个分类器结果的矩阵。对于最常见的二元分类来说，它的混淆矩阵是2乘2的，如下：</p><p><img src="image-20230626115911785.png" alt="混淆矩阵"></p><p>TP：预测正确的正例数</p><p>FN：预测错误的正例数</p><p>FP：预测错误的负例数</p><p>TN：预测正确的负例数</p><h3 id="常用评价标准的概念"><a href="#常用评价标准的概念" class="headerlink" title="常用评价标准的概念"></a>常用评价标准的概念</h3><ul><li><p>准确率（Precision）</p><ul><li><p>表示模型预测正确的正例样本TP占所有预测为正例样本（TP+FP）的比例，公式为：</p><p><img src="image-20230626120031069.png" alt="Precision"></p></li></ul></li></ul><ul><li><p>召回率（Recall）</p><ul><li><p>也被称为查全率，是在所有实际为正例的样本（TP+FN）中，被正确预测为正例的样本比例，公式为：</p><p><img src="image-20230626120123758.png" alt="Recall"></p></li></ul></li><li><p>f1分数（F1 Score）</p><ul><li><p>平衡f分数，将准确率和召回率这两个分值合并为一个分值，合并过程中，认为召回率和准确率同等重要，公式为：</p><p><img src="image-20230626120202786.png" alt="F1 Score"></p></li></ul></li><li><p>ROC和AUC</p></li><li><p>真正类率TPR: TP/(TP+FN),代表分类器预测的正类中实际正实例占所有正实例的比例。Sensitivit</p></li><li><p>负正类率FPR: FP/(FP+TN)，代表分类器预测的正类中实际负实例占所有负实例的比例。1-Specificity</p></li><li><p>真负类率TNR: TN/(FP+TN),代表分类器预测的负类中实际负实例占所有负实例的比例，TNR=1-FPR。</p></li><li><p>ROC 指的是受试者工作特征缺陷，反应敏感性与特异性关系的曲线。</p></li><li><p>横轴FPR：负正类率特异度，划分实例中所有负例占所有负例的比例，FPR越大，预测正类中实际负类越多</p></li><li><p>纵轴TPR：真正类率灵敏度，TPR越大，预测正类中实际正类越多</p></li><li><p>AUC 指的是曲线ROC下方的面积，用来表示预测准确率，AUC越高，曲线下方面积越大，说明准确率越高，曲线约接近左上角。</p><p><img src="image-20230626120411471.png" alt=""></p></li></ul><h1 id="小记总结"><a href="#小记总结" class="headerlink" title="小记总结"></a>小记总结</h1><ul><li><p>什么是监督学习</p><ul><li>通过让机器学习大量带有标签的样本，训练一个可以根据输入得到相应输出的模型。</li></ul></li><li><p>什么是无监督学习</p><ul><li>无监督学习是一种机器学习的训练方式，在没有标签的数据里可以发现潜在的一些结构的一种训练方式。</li></ul></li><li><p>什么是分类</p><ul><li>是一种监督学习，输出变量为有限个离散变量的预测问题为分类问题。</li></ul></li><li><p>什么是回归</p><ul><li>是一种监督学习，输出变量为连续数值型的预测问题为回归问题。</li></ul></li><li><p>决策树算法的优缺点</p><ul><li>优势，清晰直观的进行工作可视化，解释性好；对数据预处理相对不严格，缺点，容易过拟合</li></ul></li><li><p>什么是线性可分问题</p><ul><li>可以用一个线性函数把两类样本分开的问题</li></ul></li><li>什么是线性不可分问题<ul><li>不可以用一个线性函数把两类样本分开的问题</li></ul></li></ul><ul><li><p>在进行模型训练之前，对原始数据通常要进行哪些预处理，其常见方法有哪些？</p><ul><li>缺失值的处理，通常可以采用删除有缺失特征的样本（仅限于少量缺失的情况）；还可以采用临近样本的均值填充。</li><li>非字符型特征的处理，通常采用独热编码（one hot）方式，将字符型特征转换为数值型。</li><li>离群值和异常值处理，对于显著距离整体样本中心的样本进行删除处理。</li></ul></li><li><p>对于分类问题，有哪些常用指标可以用来评估模型的性能，写出其计算公式？</p><ul><li><p>准确率 = TP/(TP+FP)；召回率 = TP/(TP+FN)；</p></li><li><p>F1 = 2 <em> 准确率 </em> 召回率/（准确率+召回率）</p><p>其中TP：预测正确的正例数，FN：预测错误的正例数，FP：预测错误的负例数，TN：预测正确的负例数</p></li></ul></li><li><p>对于回归问题，有哪些常用指标可以用来评估模型的性能，写出其计算公式？</p><ul><li><p>RMSE 均方根误差 ；</p><p>MAPE 平均百分比误差 。</p><p><img src="a3569cd9f1ba63bc739d674662e1a946.png" alt="img"></p><p><img src="366252c0b31d18c0409a287df64423ba-1687751398068-5.png" alt="MAPE"></p></li></ul></li></ul><ul><li>分类实验中，正样本和负样本的比率差异特别大时，可以采用什么方法尽量提高模型性能？<ul><li>可以从数量大的类别中随机挑选同数量少的类别相近的样本，然后进行训练。</li><li>可以随机重复从类别少的样本中重复抽取样本，直至总数和类别多的样本相近为止。</li></ul></li></ul><ul><li><p>什么是过拟合？</p><ul><li>训练数据上能够获得较好的拟合， 但是在训练数据外的数据集上却不能很好地拟合数据，此时认为这个假设出现了过拟合的现象。出现这种现象的主要原因是训练数据中存在噪音或者训练数据太少</li></ul></li><li><p>什么是欠拟合？</p><ul><li>对于训练好的模型，若在<a href="https://baike.baidu.com/item/训练集/205998?fromModule=lemma_inlink">训练集</a>表现差，在测试集表现同样会很差，这可能是欠拟合导致。欠拟合是指模型拟合程度不高，数据距离拟合曲线较远，或指模型没有很好地捕捉到数据特征，不能够很好地拟合数据。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>求职规划</title>
    <link href="/2023/06/24/%E6%B1%82%E8%81%8C%E8%A7%84%E5%88%92/"/>
    <url>/2023/06/24/%E6%B1%82%E8%81%8C%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="1-学习计划"><a href="#1-学习计划" class="headerlink" title="1.学习计划"></a>1.<strong>学习计划</strong></h1><p><img src="/2023/06/24/%E6%B1%82%E8%81%8C%E8%A7%84%E5%88%92/image-20230624110035295.png" alt="image-20230624110035295"></p><h1 id="2-简历指导"><a href="#2-简历指导" class="headerlink" title="2.简历指导"></a><strong>2.简历指导</strong></h1><p><strong>简历字数并非越多越好，任何关键词都可能引起面试官的考察兴趣</strong></p><ul><li><p>基础信息：</p><ul><li>书写顺序：个人信息-&gt;教育经历（获奖经历）-&gt;专业技能-&gt;<strong>实习（而非工作）</strong>经历-&gt;项目经验</li><li>文件名：姓名-院校-电话</li><li>文件格式：pdf（word排版会乱）</li><li>模版：冷色调、不要表格</li></ul></li><li><p>基本信息：<em>求职意向</em>、电话、出生年月、邮箱、<em>照片</em></p><ul><li>个人博客&#x2F;Github视情况而定</li><li>邮箱：必须为常用邮箱</li><li>意向城市：强需求可以填写</li></ul></li><li><p>教育经历：学校、专业、学历、<strong>时间区间</strong></p><ul><li>主修课程：经得住问，可以写</li><li>竞赛经历：算法题难度增加</li></ul></li><li><p>专业技能：<strong>精通</strong> &gt; 熟悉 &gt; 熟练使用&#x3D;掌握 &gt; 了解</p><ul><li>专注<ul><li>不能同时熟悉Java、C++</li></ul></li><li>不能同时熟悉MySQL、Oracle</li><li>不要存在单词错误、大小写错误</li><li>结构层次、分门别类</li><li>数据结构与算法不建议提及</li><li>不建议出现的关键词：深入、精通、扎实、经验丰富</li></ul></li><li><p>自我评价：不需要</p></li></ul><p><strong>目的：让面试官快速了解项目背景，与面试官有的聊</strong></p><ul><li><p>项目来源：【1-2要标明清楚】</p><ul><li><p>实习经历的项目</p></li><li><p>学校的生产项目（学校的XX系统）</p></li><li><p>学校的课程设计 或者 练手项目</p></li></ul></li><li><p>项目数量：2-3个</p></li><li><p>项目 &#x3D; 产品 + 技术 + 结果（传达给简历阅读者的信息）</p><ul><li>项目描述：做了什么产品</li><li>技术栈：用到了什么技术<strong>（与专业技能相辅相成）</strong></li><li>取得了什么结果<ul><li>规模（量化指标）：用户规模，资金规模等<ul><li>若规模较大&#x2F;场景较为明显，要想好“如何支撑”</li></ul></li><li>角色：主导者、参与者<ul><li>作为参与者，可以适当包装，但要清楚细节</li><li>作为主导者，可以讲明带领的团队人数</li></ul></li><li>推荐描述方式：<ul><li>通过XXX实现XXX，达到XX效果</li></ul></li></ul></li></ul></li><li><p>项目书写其他技巧：</p><ul><li>按照时间倒序写</li><li>详细的项目描述将亮点写在前面</li><li>岗位无关的项目尽量少写</li></ul></li><li><p><strong>建议的项目描述模版</strong></p></li></ul><p>项目名称                      所属组织&#x2F;公司                               时间区间</p><p>项目描述： 2-5句话内描述清楚主要功能。</p><p>角色：参与者&#x2F;主导者</p><p>技术栈：A、B、C、D、E、F（重要的放前面）</p><ol><li><p>通过X实现了Y，达到了Z的效果</p></li><li><p>通过X实现了Y，达到了Z的效果</p></li><li><p>通过X实现了Y，达到了Z的效果</p></li><li><p>通过X实现了Y，达到了Z的效果</p></li></ol><p>[个数：3-6]</p><h1 id="3-学习方法"><a href="#3-学习方法" class="headerlink" title="3.学习方法"></a>3.学习方法</h1><p><img src="/2023/06/24/%E6%B1%82%E8%81%8C%E8%A7%84%E5%88%92/image-20230624110406108.png" alt="image-20230624110406108"></p><p><img src="/2023/06/24/%E6%B1%82%E8%81%8C%E8%A7%84%E5%88%92/image-20230624110428930.png" alt="image-20230624110428930"></p><h1 id="4-知识图谱"><a href="#4-知识图谱" class="headerlink" title="4.知识图谱"></a><strong>4.知识图谱</strong></h1><p><img src="/2023/06/24/%E6%B1%82%E8%81%8C%E8%A7%84%E5%88%92/4adf3b8e-6786-4fc8-892b-521ca5e4edaf.png"></p><p><strong>红色：高频考点</strong></p><p><strong>橙色：中频考点</strong></p><p><strong>黑色：低频考点</strong></p><h1 id="5-附录"><a href="#5-附录" class="headerlink" title="5.附录"></a><strong>5.附录</strong></h1><p><strong>书籍推荐</strong></p><p>关于看书学习&#x2F;上网学习的几点建议：</p><ol><li>写的比较好的书是前后逻辑是很强的，利于理解。网上的博文的作者不一定有毅力坚持，往往烂尾，且天下文章一大抄，其中的错误可能被广为流传。</li><li>背面试题 vs 技术理解：一个是招式，一个是内功，相辅相成，缺一不可。</li><li>购买前查看简介，基于的版本，是不是如今的主流版本。</li><li>针对于“比较新的又没有大规模实践的”技术的书籍可以不买，看官方文档。</li></ol><p>刷题：</p><ul><li>理解：《漫画算法 小灰的算法之旅》</li><li>刷题：《剑指Offer》</li></ul><p>Java基础：</p><ul><li>大杂烩基础：《Effective Java》（第三版）</li><li>并发：《Java并发编程实战》</li><li>JVM：《深入理解Java虚拟机》（第三版）</li></ul><p>Mysql：</p><ul><li>进阶：《MySQL技术内幕:InnoDB存储引擎》</li></ul><p>Linux：</p><ul><li>鸟哥的Linux私房菜（基础学习篇）</li></ul><p>视野拓宽与技术理解：</p><ul><li>《码农翻身》</li><li>《代码整洁之道》</li><li>《重构：改善既有代码的设计》</li><li>《领域驱动设计》</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引原理</title>
    <link href="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    <url>/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Mysql概述"><a href="#1-Mysql概述" class="headerlink" title="1.Mysql概述"></a>1.Mysql概述</h1><ul><li><p>介绍：Oracle旗下开源的最流行的关系型数据库（Relational Database Management System）管理系统。</p></li><li><p>常见面试题：</p><ul><li>SQL与Mysql区别：<ul><li>SQL(Structured Query Language)是一种查询数据库的标准计算机语言，可以查询关系型数据库，包括但不限于Mysql。</li><li>Mysql是关系型数据库，支持SQL语言，但不支持全部的SQL（例如full outer join）</li></ul></li><li>Mysql与Oracle使用场景区别：<ul><li>错误答案：大公司用Oracle，小公司用mysql</li><li>正确答案：金融场景会使用Oracle</li></ul></li><li>RDMS与NoSQL的主要区别：<ul><li>强一致性、弱一致性</li><li>不可水平拓展、可水平拓展</li></ul></li><li>NewSQL：可水平扩展的RDMS，代替“中间件+关系型数据库分库分表”，例如TiDB、OceanBase</li><li>DML、DDL、DCL：数据操作语言、数据定义语言、数据控制语言</li></ul></li><li><p>客户端与服务端通讯方式：</p><ul><li>TCP&#x2F;IP</li><li>命名管道和共享内存【Windows】</li><li>Unix域套接字文件【Unix系】</li></ul></li></ul><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/43c52a51-111e-4fda-89b0-dda8f5d1414a.png" alt="MySQL逻辑层次图"></p><p><strong>MysqlServer层：连接管理、解析与优化</strong> </p><ul><li>查询缓存：5.7.20不推荐，8.0删除<ul><li>表的任何变动都会失效</li><li>前后两次查询SQL完全一致</li></ul></li><li>语法解析</li><li>查询优化：<strong>执行计划等（EXPLAIN）</strong></li></ul><p><strong>存储引擎层：</strong>负责数据的存储和提取。</p><ul><li><strong>InnoDB</strong>：默认且最为常用</li><li><strong>MyISAM</strong></li><li>其他存储引擎：Memory、Archive等</li></ul><p><strong>查询计划是MysqlServer层的职责，不跟随存储引擎而改变</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Mysql提供给存储引擎需要实现的接口实例（部分）：<br><br><span class="hljs-comment">//使用索引前调用该方法</span><br><br><span class="hljs-built_in">int</span> ha_foo::index<span class="hljs-constructor">_init(<span class="hljs-params">uint</span> <span class="hljs-params">keynr</span>, <span class="hljs-params">bool</span> <span class="hljs-params">sorted</span>)</span> <br><br><span class="hljs-comment">//使用索引后调用该方法</span><br><br><span class="hljs-built_in">int</span> ha_foo::index<span class="hljs-constructor">_end(<span class="hljs-params">uint</span> <span class="hljs-params">keynr</span>, <span class="hljs-params">bool</span> <span class="hljs-params">sorted</span>)</span><br><br><span class="hljs-comment">//读取索引第一条内容</span><br><br><span class="hljs-built_in">int</span> ha<span class="hljs-constructor">_index_first(<span class="hljs-params">uchar</span> <span class="hljs-operator">*</span> <span class="hljs-params">buf</span>)</span>;<br><br><span class="hljs-comment">//读取索引下一条内容</span><br><br><span class="hljs-built_in">int</span> ha<span class="hljs-constructor">_index_next(<span class="hljs-params">uchar</span> <span class="hljs-operator">*</span> <span class="hljs-params">buf</span>)</span>;<br><br><span class="hljs-comment">//读取索引前一条内容</span><br><br><span class="hljs-built_in">int</span> ha<span class="hljs-constructor">_index_prev(<span class="hljs-params">uchar</span> <span class="hljs-operator">*</span> <span class="hljs-params">buf</span>)</span>;<br><br><span class="hljs-comment">//读取索引最后一条内容</span><br><br><span class="hljs-built_in">int</span> ha<span class="hljs-constructor">_index_last(<span class="hljs-params">uchar</span> <span class="hljs-operator">*</span> <span class="hljs-params">buf</span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li>Innodb与Myisam引擎的区别</li></ul><p>Myisam：支持表锁；不支持外键，事务；表的索引与数据在不同的文件；支持全文索引；允许没有主键</p><p>Innodb：支持行锁、表锁；支持外键，事务；表索引与数据在同一的文件；不支持全文索引（5.6+开始支持）；会有默认主键</p><ul><li>数据库的1NF、2NF、3NF：</li></ul><p>1NF：关系中每一分量不可再分。即不能以集合、序列等作为属性。大白话：列不能存多个属性</p><p>2NF：在1NF基础上，消除非主属性对键的部分依赖。大白话：不同实体的表不要存在一张表里</p><p>3NF：在2NF基础上，消除非主属性对键的传递依赖。大白话：不要有重复字段</p><h1 id="2-Mysql索引概述"><a href="#2-Mysql索引概述" class="headerlink" title="2.Mysql索引概述"></a>2.Mysql索引概述</h1><ul><li><p>What？</p><ul><li>帮助Mysql高效获取数据的数据结构。</li></ul></li><li><p>Why？</p><ul><li>加快查询速度。（否则只能全表扫描）</li><li>代价：额外的存储空间</li></ul></li><li><p>How？</p><ul><li>增：CREATE  &lt;索引类型&gt; INDEX &lt;索引的名字&gt; ON <table_name>(列的列表)；</li><li>删：DROP INDEX <index_name> ON <table_name>;</li><li>查：SHOW INDEX FROM <table_name>;</li><li><strong>强制指定索引</strong>：select &lt;列名&gt; from <table_name>  where &lt;查询条件&gt; force index(${index_name})</li></ul></li></ul><p>面试题1：当mysql执行计划选择错了索引，怎么办？</p><p>面试题2（非主流）：一个表最多可以可以新建多少个索引？16个？谈谈你对这个限制的理解</p><h2 id="Mysql索引类别【重点】"><a href="#Mysql索引类别【重点】" class="headerlink" title="Mysql索引类别【重点】"></a>Mysql索引类别【重点】</h2><ul><li><p>按照实现的数据结构区分：</p><ul><li><strong>B+树</strong>索引（InnoDB,MyISAM存储引擎）</li><li>Hash索引（Memory存储引擎等）</li><li>倒排索引（ InnoDB,MyISAM存储引擎针对全文索引）</li><li>LSM-Tree索引：Hbase、OceanBase的索引数据结构</li></ul></li><li><p>按照约束（或者创建语句）区分：</p><ul><li>普通索引： CREATE  INDEX</li><li>唯一索引： CREATE  UNIQUE INDEX</li><li>主键索引： 创建表自带， { PRIMARY KEY (<code>id</code>) }</li><li>全文索引： CREATE  FULLTEXT INDEX<strong>【没人用，ES替代】</strong></li></ul></li><li><p>按照索引列的数量区分：</p><ul><li>单列索引</li><li>联合索引（复合索引、组合索引）【最左匹配原则】</li></ul></li><li><p>按照存储的内容区分(innodb存储引擎)</p><ul><li>聚簇索引：存储了索引列与数据【索引即数据，数据即索引】</li><li>非聚簇索引（辅助索引&#x2F;二级索引）：存储了索引列与主键</li></ul></li></ul><p>检查理解情况：（判断题）</p><ol><li>主键索引是单列索引，也是聚餐索引。</li><li>使用CREATE INDEX语句创建的索引均为辅助索引。</li><li>聚餐索引存储了mysql表的所有的数据，支持按照主键查询。</li><li>使用Innodb存储引擎的表的主键索引是B+树索引。</li><li>使用Innodb存储引擎的表聚簇索引与非聚餐索引均采用B+树索引，存储原理是一致的。</li></ol><p><strong>注意：</strong></p><p>只有B树，B+树</p><p>B-树 &#x3D; B树，<strong>不要读B减树</strong></p><ul><li><p>面试题1：Key（键&#x2F;约束）与Index（索引）的区别与联系：</p><ul><li>Index：方便查询</li><li>Key：方便查询 + 约束（主键、唯一键、外键）</li></ul></li><li><p>最左匹配原则:以最左边的为起点任何连续的索引都可匹配</p></li><li><p>面试题2：</p></li><li><p>索引：index(a, b, c )</p></li><li><p>以下查询语句是否可以使用此索引：</p></li></ul><ol><li>where a &#x3D; 1：ok</li><li>where a &#x3D; 1 and c &#x3D; 1：索引效果与上面一样</li><li>where b &#x3D; 1：不ok</li><li>where a &#x3D; 1 and b &#x3D; 1 ：ok</li><li><strong>where b &#x3D; 1 and a &#x3D; 1：k【与条件先后顺序无关】</strong></li></ol><ul><li>面试题3：有哪些索引？</li></ul><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><ul><li>mysql innodb等值查询除了会使用到B+树索引，还可能使用到什么索引？</li><li>谈谈哈希索引（自适应hash索引）<ul><li>哈希索引适合等值查询，但是无法进行范围查询</li><li>哈希索引没办法利用索引完成排序 </li><li>哈希索引不支持多列联合索引的最左匹配规则 </li><li>如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题</li><li>由innodb自行建立维护，DBA无法介入</li></ul></li><li>谈谈哈希索引与B+树索引的区别？</li></ul><h1 id="3-Innodb记录格式"><a href="#3-Innodb记录格式" class="headerlink" title="3.Innodb记录格式"></a>3.Innodb记录格式</h1><p><strong>行格式：</strong></p><ul><li><p>What 行？</p><ul><li>执行 insert into <table_name> values(&lt;值&gt;) 语句便向数据库插入了一条数据，此条数据称之为行或者记录</li></ul></li><li><p>What 行格式？</p><ul><li>存储上述行（或记录）在磁盘上的存放方式，即行格式&#x2F;记录格式</li></ul></li><li><p>How 行格式？</p><ul><li>指定：CREATE TABLE 表名 (列的信息) ROW_FORMAT&#x3D;行格式名称</li><li>修改：ALTER TABLE 表名 ROW_FORMAT&#x3D;行格式名称</li></ul></li><li><p>行格式的类型有哪些？</p><ul><li>Redundant：5.0-，冗余行格式，远古时期</li><li>Compact：5.6默认</li><li><strong>Dynamic</strong>：5.7+默认，动态行格式，和Compact区别不大，仅在行溢出情况下存在区别</li><li>Compressed：压缩行格式，采用压缩算法节约磁盘空间，仅在数据归档时才会使用</li></ul></li></ul><p><strong>Dynamic行格式【重点】</strong></p><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/3cd7d80a-ad09-489e-a1b6-c7aeac85cad1.png" alt="示意图"></p><p><strong>记录存储在“页”中，一页16KB</strong></p><p>记录的额外信息：</p><ul><li>变长字段长度列表：变长字段（占用存储字节数不固定的字段，例如VARCHAR）的实际长度</li><li>NULL值列表：<ul><li>标示了哪些列：主键列、被NOT NULL修饰的列都是不可以存储NULL值，其他都存储</li><li>如何标示：二进制位的值为1时，代表该列的值为NULL；二进制位的值为0时，代表该列的值不为NULL</li><li>占用的字节数：必须用整数个字节的位表示（如果使用的二进制位个数不是整数个字节，则在字节的高位补0）</li></ul></li><li>记录头信息：占用5个字节（40位）<ul><li><strong>delete_mask：该记录是否被删除</strong></li><li><strong>next_record：下一条记录的相对位置（并不是插入顺序的下一条记录，而是按照主键值&#x2F;索引列值的下一条记录）</strong></li><li>record_type：记录类型， 0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li><li>heap_no：当前记录所属的<strong>页</strong>号</li><li>其他（预留位1、预留位2、 min_rec_mask、 n_owned）</li></ul></li></ul><p>记录的真实数据：</p><ul><li>隐藏列：<ul><li><strong>row_id</strong>：行ID，非必须，无主键且无NOT NULL的UK时才会有</li><li>transaction_id：事务ID</li><li>roll_pointer：回滚指针</li></ul></li><li>数据列：存储真实的数据</li></ul><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/84d18ac1-f7c3-49be-b533-28b7ccae069e.png" alt="示意图2"></p><p>其他概念-行溢出：当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中的现象</p><p>面试题1：delete语句之后，空间会不会自动释放？</p><p>答：不会，会将此记录标记为己删除，页内已删除的记录做为一个<strong>垃圾链表</strong>，下次需要向此页插入数据时，优先使用此块空间。</p><p>面试题2：表创建时无主键，会怎么办？</p><p>答：</p><ol><li>首先选择第一个被NOT NULL修饰的UK索引做为聚簇索引</li><li>若无，则会在记录中添加隐藏列的row_id</li></ol><p>面试题3：为什么查询数据时不建议select *</p><ol><li>网络IO  2.  发生回表现象   3.  回表时命中溢出页</li></ol><h1 id="4-Innodb页格式"><a href="#4-Innodb页格式" class="headerlink" title="4.Innodb页格式"></a>4.Innodb页格式</h1><h2 id="索引页-x2F-数据页"><a href="#索引页-x2F-数据页" class="headerlink" title="索引页&#x2F;数据页"></a>索引页&#x2F;数据页</h2><p>页： InnoDB管理存储空间的基本单位，也是MySQL中磁盘和内存交互的基本单位，一个页的大小一般是16KB</p><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/49278afe-ad09-402b-b1d2-f47bbf9820aa.png" alt="数据页/索引页格式示意图"></p><ul><li><p>文件头：File Header，页的一些通用信息</p><ul><li>页号</li><li>校验和：与页尾一起校验页是否完整，刷盘时首先写校验和，通过和文件尾的校验和一同判断是否存在同步一半的情况。</li><li><strong>上一个页的页号、下一个页的页号：组成B+树的双向链表</strong></li></ul></li><li><p>页头：Page Header，数据页专有的一些信息</p><ul><li>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</li><li><strong>第一个已经标记为删除的记录地址【为了找到垃圾链表，插入数据】</strong></li><li><strong>还未使用的空间最小地址【为了插入数据】</strong></li><li>页类型等其他</li></ul></li><li><p><em>虚记录</em>：最小虚记录和最大虚记录</p><ul><li>最小虚记录：此记录的next_record指向本页中最小的记录</li><li>最大虚记录：指向本页中最大的记录的next_record指向此记录</li></ul></li><li><p><em>用户记录</em>*&#x2F;*<em>记录堆</em>：实际存储的记录内容，由一堆行记录组成</p><ul><li>既有有效记录，又有已删除的记录</li></ul></li><li><p>未分配空间：页中尚未使用的空间</p><ul><li>下次需要向此页插入数据时，若无垃圾链表，则会使用此块空间。</li></ul></li><li><p><em>页目录</em><em>&#x2F;Slot**区</em>：页中的某些记录的相对位置，为了快速查询</p></li><li><p>文件尾：与页头一起校验页是否完整</p></li></ul><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/9ee83e74-fffd-4868-a7a9-78da7001cb1b.png" alt="示意图3"></p><h2 id="记录的页内插入"><a href="#记录的页内插入" class="headerlink" title="记录的页内插入"></a>记录的页内插入</h2><ul><li><p>插入位置：</p><ul><li>垃圾链表（页头记录了第一个已经标记为删除的记录地址）</li><li>未分配的空间（页头记录了还未使用的空间最小地址）</li></ul></li><li><p>插入策略：物理有序 vs 逻辑有序</p><ul><li>举例：依次插入顺序10、9、8</li></ul><p>物理有序：</p></li></ul><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/c603392e-8c89-44f1-992d-ee36fa0f21a2.png" alt="物理有序"></p><p>逻辑有序：</p><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/98dadc07-8cf8-4362-9403-1e80d1a4904d.png" alt="逻辑有序"></p><h2 id="记录的页分裂【重点】"><a href="#记录的页分裂【重点】" class="headerlink" title="记录的页分裂【重点】"></a>记录的页分裂【重点】</h2><ul><li>该页装不下怎么办？假设页10只能装下3条记录，现在要插入id&#x3D;4的记录</li></ul><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/image-20230624094252434.png" alt="image-20230624094252434"></p><p>思考：<strong>为什么mysql主键不建议使用UUID</strong></p><ul><li>在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>。这个过程我们也可以称为页分裂。</li></ul><h2 id="记录的页内查找（了解）"><a href="#记录的页内查找（了解）" class="headerlink" title="记录的页内查找（了解）"></a><strong>记录的页内查找（了解）</strong></h2><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/image-20230624094451483.png" alt="image-20230624094451483"></p><p><strong>问：此时查找id&#x3D;3的数据的时间复杂度是多少？</strong></p><h2 id="记录的页内二分查找（了解）"><a href="#记录的页内二分查找（了解）" class="headerlink" title="记录的页内二分查找（了解）"></a><strong>记录的页内二分查找（了解）</strong></h2><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/336a7b3f-3469-4bb8-9592-2c2584412b95.png"></p><ul><li>Slot区：也称Page Directory区，页<strong>目录</strong>区，记录页中的某些记录的相对位置。</li><li>Slot：槽，对于页内记录（含最大记录与最小记录，不包括标记为已删除的记录）进行<strong>分组</strong>，每个组的最后一条记录的地址偏移量即为槽。<ul><li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录</li></ul></li></ul><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/5acc62c9-e566-4504-9058-08543f2d65ce.jpeg"></p><ul><li><p>分组依据：</p><ul><li>对于最小记录所在的分组只能有 1 条记录</li><li>最大记录所在的分组拥有的记录条数只能在 1~8 条之间</li><li>剩下的分组中记录的条数范围只能在是 4~8 条之间</li></ul></li><li><p>如何二分查找：O(Log2N)</p><ul><li><p>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录二分过程：(high槽 + low槽) &#x2F; 2 得到当前槽，判断当前槽所指记录的大小，决定high&#x2F;low的变化查找主键值最小的那条记录：(high – 1)槽所指的记录的next_record</p></li><li><p>通过记录的next_record属性遍历该槽所在的组中的各个记录</p></li></ul></li></ul><h2 id="5-再看B-树索引【重点】"><a href="#5-再看B-树索引【重点】" class="headerlink" title="5.再看B+树索引【重点】"></a>5.<strong>再看B+树索引【重点】</strong></h2><p><strong>B+树聚簇索引</strong></p><ul><li><ol><li>页之间存在双向链表（通过页的文件头区域的“上一页的页号”与“下一页”页号）</li></ol><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/image-20230624095018218.png" alt="image-20230624095018218"></p></li></ul><p>此时查找办法：从左到右遍历页，看当前记录是否在最小记录与最大记录之间，若不在则判断下一页，若在则在页内二分查找。</p><ul><li><ol start="2"><li>给每个页建立个目录，记录“页的用户记录中最小的主键值”与页号</li></ol><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/image-20230624095038737.png" alt="image-20230624095038737"></p></li></ul><p>此时的查找方法：在目录页二分查找（距离此记录最近的所在的页），再在目标页内，二分查找。</p><ul><li><ol start="3"><li>“目录”太多，一页装不下，分多个页来装。</li></ol><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/a84807a4-42fb-4477-adfc-5ab136b63556.png"></p></li></ul><p>此时的查找方法：先从根页查找“距离此记录最近的记录”所在的页，再到索引页“距离此记录最近的记录”，最后到叶子节点二分查找</p><ul><li>根节点：存放索引信息（或者称为目录项）的页</li><li>非叶子节点（内节点）：存放索引信息的页<ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</li></ul></li><li>叶子节点（外节点）：存放索引信息与<strong>实际数据</strong>的页<ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</li></ul></li></ul><p>Innodb的聚簇索引与非聚簇索引均采用此结构进行存储，区别在于：</p><ol><li>聚簇索引的叶子节点存储的是全量数据</li><li>非聚簇索引的叶子节点存储的是索引列的值 + 主键</li></ol><p>下一个数据页中用户记录的索引列值必须<strong>大于</strong>上一个页中用户记录的索引列值。</p><p>&#x3D;&gt;  </p><p><strong>非聚簇索引的存储的索引数据一定会有主键</strong>。</p><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/62031496-6d9c-4051-8514-24edf4aa3b0c.png"></p><p>**如上图某非聚簇索引橙色为索引的key绿色为页号蓝色为主键 **</p><p>此时若插入索引key&#x3D;1的数据改插入到页4还是页5？</p><p>面试题：</p><p>表：user（id，name、sex）</p><p>查询条件： where name &#x3D; ？ and sex &#x3D;? order by id</p><p>为了高效查询，建立索引有4种方式，以下哪种最优？</p><ol><li>idx_name_sex_id（name、sex、id）</li><li>idx_sex_ name_ id （sex、name、id）</li><li>idx_sex_name（sex、name）</li><li>idx_name_sex （name、 sex）</li></ol><h1 id="6-索引的使用"><a href="#6-索引的使用" class="headerlink" title="6.索引的使用"></a>6.索引的使用</h1><h2 id="访问类型概述"><a href="#访问类型概述" class="headerlink" title="访问类型概述"></a>访问类型概述</h2><p>访问类型：也称访问方法，access method，MySQL执行查询语句的方式。</p><ul><li>使用全表扫描进行查询（all）</li><li>使用索引进行查询（const、ref、ref_or_null、range、index等）</li></ul><p>注意：<strong>数据量大的表，一定要避免all的发生</strong></p><h3 id="访问类型-const"><a href="#访问类型-const" class="headerlink" title="访问类型-const"></a>访问类型-const</h3><ul><li>const：<ul><li>直接利用主键值在聚簇索引中定位对应的一条记录</li><li>根据唯一辅助索引列来定位一条记录</li></ul></li></ul><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/73f050bf-37a5-48f4-9505-b22d818f2d2d.png"></p><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/06430fec-9f61-45d6-84a5-d6bd991416a9.png"></p><h3 id="访问类型-ref【重点】"><a href="#访问类型-ref【重点】" class="headerlink" title="访问类型-ref【重点】"></a>访问类型-ref【重点】</h3><ul><li><p>ref：对某个普通的二级索引列与常数进行等值比较</p></li><li><p><strong>回表：通过辅助索引查询到的数据，不包含用户查询的全量数据，需要用主键去聚簇索引中再次查询的过程。（随机IO）</strong></p></li><li><p><strong>索引覆盖：只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表。</strong></p></li></ul><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/268b086b-6fba-4728-b54c-a3d73a225074.png"></p><p>面试题：</p><ol><li>为什么不select *？</li><li>什么是索引覆盖？</li><li>为什么要尽量避免回表？</li></ol><h3 id="访问类型-ref-or-null"><a href="#访问类型-ref-or-null" class="headerlink" title="访问类型-ref_or_null"></a>访问类型-ref_or_null</h3><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/268b086b-6fba-4728-b54c-a3d73a225074-1687571895894-20.png"></p><h3 id="访问类型-range"><a href="#访问类型-range" class="headerlink" title="访问类型-range"></a>访问类型-range</h3><ul><li>range：区间查询，使用&#x3D;、&lt;&#x3D;&gt;、IN、NOT IN、IS NULL、IS NOT NULL、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、BETWEEN、!&#x3D;、 &lt;&gt;、like左匹配，就可以产生一个所谓的区间。</li></ul><p>举例：SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 &gt;&#x3D; 38 AND key2 &lt;&#x3D; 79);</p><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/image-20230624095852531.png" alt="image-20230624095852531"></p><h3 id="访问类型-index"><a href="#访问类型-index" class="headerlink" title="访问类型-index"></a>访问类型-index</h3><ul><li>index：查询的值以及返回的结果恰好在某个辅助索引里，但是无法通过索引列查询，全部扫描此索引。</li></ul><p>举例：</p><p>表：</p><p>CREATE TABLE single_table (</p><p>​    id INT NOT NULL AUTO_INCREMENT,</p><p>​    key1 VARCHAR(100),</p><p>​    key2 INT,</p><p>​    key3 VARCHAR(100),</p><p>​    key_part1 VARCHAR(100),</p><p>​    key_part2 VARCHAR(100),</p><p>​    key_part3 VARCHAR(100),</p><p>​    common_field VARCHAR(100),</p><p>​    PRIMARY KEY (id),</p><p>​    <strong>KEY</strong> <strong>idx_key_part(key_part1, key_part2, key_part3)</strong></p><p>) Engine&#x3D;InnoDB CHARSET&#x3D;utf8;</p><p>查询语句：SELECT <strong>key_part1, key_part2, key_part3</strong> FROM single_table WHERE key_part2 &#x3D; ‘abc’; </p><p>辅助索引的数据比聚簇索引的数据小，全表所描辅助索引，也是个不错的选择</p><h2 id="索引的注意事项"><a href="#索引的注意事项" class="headerlink" title="索引的注意事项"></a><strong>索引的注意事项</strong></h2><ol><li>ORDER BY子句里使用到了我们的索引列（但是 oder by a asc, b desc, c desc不行）</li><li>只为用于搜索、排序或分组的列创建索引</li><li>列的区分度大的列创建索引，重复数据多的字段不应设为索引</li><li>更新频繁的列不应设置索引</li><li>重复数据多的字段不应设为索引的例外情况（状态字段&#x3D;有效&#x2F;无效，仅根据“有效”查询时，可以建立）</li><li>联合索引，区分度大的列放在第一位</li><li>只有索引列在比较表达式中单独出现才可以适用索引 （ a &gt; 2 可以，a + 1 &gt; 1不行）</li><li>为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT属性。</li><li>尽量使用覆盖索引进行查询，避免回表带来的性能损耗。</li><li>使用IN查询，IN的数量不能太大（&lt;&#x3D;2000），避免mysql走错索引</li><li>Mysql会根据I&#x2F;O成本以及CPU成本去估算，选择最终执行计划</li><li>LIKE 右模糊（like kw%）可以使用到索引，LIKE左模糊（like %kw） 、全模糊（like %kw%）无法使用到索引。</li></ol><p>神兵利器：</p><ul><li><strong>EXPLAIN</strong>：查看SQL的执行计划的结果。</li><li>optimizer trace：查看生成执行计划的整个过程。</li></ul><p><strong>面试题：</strong></p><ol><li><strong>如何判断SQL走的是哪个索引？</strong></li><li><strong>如何优化慢SQL？</strong></li><li><strong>建立索引有哪些注意事项？</strong></li></ol><h1 id="7-其他应该知道的知识点"><a href="#7-其他应该知道的知识点" class="headerlink" title="7.其他应该知道的知识点"></a>7.其他应该知道的知识点</h1><h2 id="innodb区-x2F-段-x2F-表空间"><a href="#innodb区-x2F-段-x2F-表空间" class="headerlink" title="innodb区&#x2F;段&#x2F;表空间"></a>innodb区&#x2F;段&#x2F;表空间</h2><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/e436a165-a427-4505-b89d-c10cbe2ebb71.jpeg"></p><ul><li><p>区：连续的64个页就是一个区。</p><ul><li>设计的目的：一个区就是在物理位置上连续的64个页，物理连续，空间的局部性原理，发生连续IO几率更高。（利用磁盘预读原理）</li></ul></li><li><p>段：存储相同类型记录的区做为一个段，一个段会有256个区，一个表空间下会有多个段，如“叶子节点段”、“非叶子节点段”。</p><ul><li>设计的目的：范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣。物理连续，空间的局部性原理，发生连续IO几率更高。</li></ul></li><li><p>表空间：为了更好的管理页，一个.idb结尾的表为一个独立表空间。</p></li></ul><h2 id="为什么使用B-树，不用B树-x2F-二叉树？"><a href="#为什么使用B-树，不用B树-x2F-二叉树？" class="headerlink" title="为什么使用B+树，不用B树&#x2F;二叉树？"></a><strong>为什么使用B+树，不用B树&#x2F;二叉树？</strong></h2><ol><li>二叉树的高度太高，每次查找都是一次磁盘IO，很慢；B+树是一个多路查找树，高度一般2-4层，矮胖，IO较少。</li><li>B+树仅在叶子节点存储数据，叶子节点之间有双向链表，范围扫描快，B树没有，B树的非叶子节点也存储数据。</li></ol><h2 id="索引下推（ICP）"><a href="#索引下推（ICP）" class="headerlink" title="索引下推（ICP）"></a>索引下推（ICP）</h2><ul><li><p>索引下推：5.6+，有效减少回表次数，从而提高效率。</p></li><li><p>例子：</p><ul><li>语句：select * from table where k1 &#x3D; a and k2 &#x3D; b，索引为idx_k12(k1, k2)</li><li>执行：innodb扫描到一条记录：k1 &#x3D; a , k2 &#x3D; c<ul><li>不使用ICP：innodb将此记录返回给mysql-server， mysql-server拿着主键去回表判断 k2 是否等于 b</li><li>使用ICP：innodb自行判断，无需mysql-server回表判断</li></ul></li></ul></li><li><p>区别：</p><ul><li>当你不使用ICP,通过使用非主键索引（普通索引or二级索引）进行查询，存储引擎通过索引检索数据，然后返回给MySQL服务器，服务器再判断是否符合条件。</li><li>使用ICP，当存在索引的列做为判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。</li></ul></li></ul><p><strong>进阶面试题：5.6之前为什么不下推？</strong></p><p><strong>所谓下推，不过是将MysqlServer做的事情下移至存储引擎来做，其实是一个很正常的操作，只不过Mysql在之前的版本，并没有把这部分判断条件传递给存储引擎，过于简单粗暴。</strong></p><h2 id="深翻页"><a href="#深翻页" class="headerlink" title="深翻页"></a>深翻页</h2><ul><li>现象：select * from table_name limit m,n;  当m很大时，查询性能急剧下降。</li><li>第一层原理：先读取符合where条件的前面m+n条记录，然后抛弃前m条，返回后面n条，所以m越大，偏移量越大，性能就越差。</li><li>第二层原理：mysql server与存储引擎的交互，首先根据索引定位到第一条，往后一条条数据往后扫描，每条数据mysql server再判断是否要用，丢弃掉了前面m条数据。</li><li>解决方案：<ul><li>优化前：select * from table_a limit 1000000, 10;</li><li>优化后：select * from table_a where id &gt; ${lastKey} limit 10;</li></ul></li><li>解决方案的局限性：<ul><li>1、没有总页数</li><li>2、只能上下翻页</li><li>3、id必须有序且唯一</li></ul></li></ul><h2 id="面试题-情景题"><a href="#面试题-情景题" class="headerlink" title="面试题-情景题"></a>面试题-情景题</h2><ul><li><p>生产环境Mysql数据库所在服务器CPU飙升，如何排查？</p></li><li><p>经验：mysql服务器的CPU飙升往往都是慢SQL导致的</p></li><li><p>问题转换 &#x3D;&gt; 如何找到慢SQL？</p></li><li><p>方法1：查看数据库的慢SQL日志  slow.log</p></li><li><p>方法2：查看CPU飙升的曲线，是从时候开始的，那段时间做了什么样的代码变更，查看查询的表与条件。</p></li></ul><h2 id="面试题-Mysql单表最多能存储多少数据？"><a href="#面试题-Mysql单表最多能存储多少数据？" class="headerlink" title="面试题-Mysql单表最多能存储多少数据？"></a>面试题-Mysql单表最多能存储多少数据？</h2><ul><li>业内经验：<ul><li>阿里巴巴《Java开发手册》：单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</li><li>互联网圈流传：MySQL 单表数据量大于 2000 W行，性能会明显下降。</li></ul></li><li>Mysql单表最多能存储多少数据？<ul><li>理论上可存储多少：取决于主键的数据类型，int为2^32 - 1，bigint为2^64 - 1</li><li>实际上可存储多少：超过了多少将影响Mysql的性能</li></ul></li><li>分析：</li></ul><p>Mysql单表最多能存储多少数据？ &#x3D;&gt; Mysql单表数据量超过多少将较大的影响mysql的性能？</p><p>影响Mysql性能的主要原因是什么？&#x3D;&gt; 索引结构，B+树索引 &#x3D;&gt; B+树的什么属性影响了性能 &#x3D;&gt; 高度（一般2-3层，2-3次IO）</p><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/4ddd953d-850b-4b13-9e46-d1bdfa7aae1a.png"></p><p><img src="/2023/06/24/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/a35c6b4a-a161-4ced-824b-65260247bd1f.png"></p><ul><li>如何理解业内经验？DBA基于大多数场景的经验</li></ul><h2 id="其他基础知识"><a href="#其他基础知识" class="headerlink" title="其他基础知识"></a>其他基础知识</h2><ul><li>表的字符集要使用，utf8mb4</li><li>表的比较规则要大小写敏感（默认不敏感），以_cs结尾的比较规则</li><li>union与union all的区别</li><li>char与varhcar的区别</li><li>左连接，右连接，内连接的区别</li><li>Mysql时间&#x2F;日期的数据类型：<a href="https://blog.51cto.com/u_15346415/3675766">https://blog.51cto.com/u_15346415/3675766</a></li><li>基础的SQL语句书写</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Java知识体系</category>
      
      <category>中间件</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java知识体系树状图</title>
    <link href="/2023/06/24/Java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A0%91%E7%8A%B6%E5%9B%BE/"/>
    <url>/2023/06/24/Java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A0%91%E7%8A%B6%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<blockquote class="pullquote mindmap mindmap-md"><ul><li>Java知识体系<ul><li>Java<ul><li>基础<ul><li>数据类型（基本类型与装箱类型）</li><li>异常</li><li>OOP（封装继承多态）</li><li>泛型</li><li>反射</li></ul></li></ul></li><li>开发框架</li><li>中间件<ul><li>MySQL<ul><li><a href="https://qgcatg.top/2023/06/24/MySQL索引原理/">索引</a></li><li>事务</li><li>锁</li><li>分布式解决方案<ul><li>主从复制</li><li>读写分离</li><li>分库分表</li><li>分布式事务</li></ul></li></ul></li><li>redis</li></ul></li><li>工程理论</li><li>工程体系</li><li>计算机基础</li></ul></li></ul></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Java知识体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_githubpages搭建博客</title>
    <link href="/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="win11-hexo-githubpages搭建博客"><a href="#win11-hexo-githubpages搭建博客" class="headerlink" title="win11_hexo_githubpages搭建博客"></a>win11_hexo_githubpages搭建博客</h1><h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 <a href="https://hexo.io/zh-cn/docs/index.html#%E5%AE%89%E8%A3%85-Hexo">安装 Hexo</a> 步骤。</p><p>如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>。</li></ul><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>安装成功后，将 git 与 GitHub 账号绑定，右键打开 Git Bash，然后设置配置信息：</p><p><img src="/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20230624014910133.png" alt="image-20230624014910133"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text"># 配置用户名和邮箱<br>git config --global user.name &quot;github 用户名&quot;<br>git config --global user.email &quot;github 注册邮箱&quot;<br></code></pre></td></tr></table></figure><p>比如我的配置就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">git config --global user.name <span class="hljs-string">&quot;qgc123&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;2467879337@qq.com&quot;</span><br></code></pre></td></tr></table></figure><p>接着生成 ssh 密钥文件，输入如下命令后直接三次回车即可，一般不需要设置密码；</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text"># 生成 ssh 密钥<br>ssh-keygen -t rsa -C &quot;github 注册邮箱&quot;<br></code></pre></td></tr></table></figure><p>我生成秘钥的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;2467879337@qq.com&quot;</span><br></code></pre></td></tr></table></figure><p>一般执行上述命令之后，会生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，前者是我们私有的，而后者则是对外开放的。接着找到生成的 <code>.ssh</code> 的文件夹中的 id_rsa.pub 密钥，将内容复制；</p><p>然后打开 <a href="https://link.zhihu.com/?target=https://github.com/settings/keys">GitHub-Settings-Keys</a> 页面，创建一个新的 SSH key，填写 <code>Title</code> 和 <code>Key</code>，<code>Title</code> 可以随意，而 <code>Key</code> 的内容则是我们刚才复制的 <code>id_rsa.pub</code> 中的内容，最后点击 <code>Add SSH key</code> 即可；</p><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>Node.js 为大多数平台提供了官方的 <a href="https://nodejs.org/zh-cn/download/">安装程序</a>。对于中国大陆地区用户，可以前往 <a href="https://npmmirror.com/mirrors/node/">淘宝 Node.js 镜像</a> 下载。</p><p>其它的安装方法：</p><ul><li>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者 <a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。</li></ul><p><strong>Windows 用户</strong></p><p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><h3 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h3><p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> hexo<br></code></pre></td></tr></table></figure><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><code>npx hexo &lt;command&gt;</code></li><li>Linux 用户可以将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27;</span> &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure><h3 id="Node-js-版本限制"><a href="#Node-js-版本限制" class="headerlink" title="Node.js 版本限制"></a>Node.js 版本限制</h3><p>如果你坚持使用旧的 Node.js，你可以考虑安装 Hexo 的过去版本。</p><p>请注意，我们不提供对过去版本 Hexo 的错误修复。</p><p>强烈建议永远安装 <a href="https://www.npmjs.com/package/hexo?activeTab=versions">最新版本</a> 的 Hexo，以及 <a href="https://hexo.io/zh-cn/docs/index.html#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">推荐的 Node.js 版本</a>。</p><table><thead><tr><th align="left">Hexo 版本</th><th align="left">最低版本 (Node.js 版本)</th><th align="left">最高版本 (Node.js 版本)</th></tr></thead><tbody><tr><td align="left">6.2+</td><td align="left">12.13.0</td><td align="left">latest</td></tr><tr><td align="left">6.0+</td><td align="left">12.13.0</td><td align="left">18.5.0</td></tr><tr><td align="left">5.0+</td><td align="left">10.13.0</td><td align="left">12.0.0</td></tr><tr><td align="left">4.1 - 4.2</td><td align="left">8.10</td><td align="left">10.0.0</td></tr><tr><td align="left">4.0</td><td align="left">8.6</td><td align="left">8.10.0</td></tr><tr><td align="left">3.3 - 3.9</td><td align="left">6.9</td><td align="left">8.0.0</td></tr><tr><td align="left">3.2 - 3.3</td><td align="left">0.12</td><td align="left">未知</td></tr><tr><td align="left">3.0 - 3.1</td><td align="left">0.10 或 iojs</td><td align="left">未知</td></tr><tr><td align="left">0.0.1 - 2.8</td><td align="left">0.10</td><td align="left">未知</td></tr></tbody></table><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>安装完成后，要查看我们是否安装成功，可以打开命令提示符（<code>Win + R</code>），输入 <code>cmd</code> 打开控制台，输入如下命令，如果出现对应版本号，说明安装成功了；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br>npm -v<br></code></pre></td></tr></table></figure><p><img src="/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20230624015114342.png" alt="image-20230624015114342"></p><h1 id="主题安装（fluid）："><a href="#主题安装（fluid）：" class="headerlink" title="主题安装（fluid）："></a>主题安装（fluid）：</h1><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h4 id="1-搭建-Hexo-博客"><a href="#1-搭建-Hexo-博客" class="headerlink" title="1. 搭建 Hexo 博客"></a>1. 搭建 Hexo 博客</h4><p>如果你还没有 Hexo 博客，请按照 <a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a> 进行安装、建站。</p><h4 id="2-获取主题最新版本"><a href="#2-获取主题最新版本" class="headerlink" title="2. 获取主题最新版本"></a>2. 获取主题最新版本</h4><p><strong>方式一：</strong></p><p>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a> 内容复制进去。</p><p><strong>方式二：</strong></p><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 themes 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><h4 id="3-指定主题"><a href="#3-指定主题" class="headerlink" title="3. 指定主题"></a>3. 指定主题</h4><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题</span><br><br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h4 id="4-创建「关于页」"><a href="#4-创建「关于页」" class="headerlink" title="4. 创建「关于页」"></a>4. 创建「关于页」</h4><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><p>其他参考<a href="https://hexo.fluid-dev.com/docs/">用户文档</a></p><h1 id="主题安装问题"><a href="#主题安装问题" class="headerlink" title="主题安装问题"></a>主题安装问题</h1><h2 id="报错：Error-Cannot-find-module-‘css’"><a href="#报错：Error-Cannot-find-module-‘css’" class="headerlink" title="报错：Error: Cannot find module ‘css’"></a>报错：Error: Cannot find module ‘css’</h2><p>只需要<br><code>npm install css --save</code></p><h1 id="插入图片问题"><a href="#插入图片问题" class="headerlink" title="插入图片问题"></a>插入图片问题</h1><h2 id="如何向hexo博客中插入图片"><a href="#如何向hexo博客中插入图片" class="headerlink" title="如何向hexo博客中插入图片"></a><strong>如何向hexo博客中插入图片</strong></h2><p>众所周知，在md文件中插入图片的语法为<code>![]()</code>。</p><p>其中<strong>方括号</strong>是图片描述，<strong>圆括号</strong>是图片路径。</p><p>一般来说有三种图片路径，分别是<strong>相对路径，绝对路径和网络路径</strong>。</p><p>所谓的网络路径就是直接引用网上的图片，直接复制图片地址，放在圆括号中就完事了。</p><p>这种方式十分的方便，但是也存在一定的问题：</p><ul><li>图片失效导致无法加载；</li><li>打开网页后要再请求加载图片；</li><li>原网站限制，如微信公众号的图片会变得不可见等。</li></ul><p>这种方式算是有利有弊。</p><p>绝对路径是图片在计算机中的绝对位置，相对路径是相对于当前文件的路径。</p><p>由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。</p><p>在hexo中使用<strong>文章资源文件夹</strong>需要在<code>config.yaml</code>文件中更改一下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>当该配置被应用后，使用<code>hexo new</code>命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。</p><blockquote><p>由于项目会生成新的文件目录，同时会解析Markdown中的图片路径，会导致一个问题。<br>如在一个文件目录下，博客名为<code>1.md</code>，相应的存在一个<code>1</code>文件夹存放图片<code>image.jpg</code>。<br>在Typora编辑器中，普通的md文件使用<code>![](1/image.jpg)</code>能在编辑器中正常显示图片。<br>在hexo中，按理说应该是使用<code>![](image.jpg)</code>，但网页中却无法正常显示。<br>此时应该使用这样的方式来引入图片：</p></blockquote><p>但是这样不方便。</p><h2 id="图片插件"><a href="#图片插件" class="headerlink" title="图片插件"></a><strong>图片插件</strong></h2><p>插件<a href="https://link.zhihu.com/?target=https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>解决了这个问题。可以只用<code>npm install hexo-renderer-marked</code>命令直接安装，之后在<code>config.yaml</code>中更改配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>之后就可以在使用<code>![](image.jpg)</code>的方式愉快的插入图片了。</p><p>我们做了这么多都是为了方便，那么为什么不再方便一点呢。</p><h2 id="hexo与Typora的完美结合"><a href="#hexo与Typora的完美结合" class="headerlink" title="hexo与Typora的完美结合"></a><strong>hexo与Typora的完美结合</strong></h2><p>上述是从文章资源文件夹中引用图片，前提是<strong>先将图片放入到文章资源文件夹</strong>，如果图片数量众多的话，一张一张的放很影响效率。但是不用怕，我们有很方便的解决方法。</p><p><strong>Typora</strong>是我非常喜欢的Markdown文本编辑器，在之前的文章中也介绍过一点。</p><p>Typora对于插入图片的支持做得非常好，在<code>文件-&gt;偏好设置</code>或者直接<code>&lt;C-,&gt;</code>进入设置。</p><p><img src="/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/v2-52220b2dba6901ee2181b72951d25a7b_720w.webp" alt="img"></p><p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p><p>如复制网络路径的图片<code>https://...../image.jpg</code>粘贴到Typora中叫<code>文章名</code>的文章后，图片会自动变为<code>![](文章名/image.jpg)</code>。</p><p>但我们知道部署后，文件路径是不同的，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的<code>文件名/</code>。不慌，也很简单。</p><p>在Typora编辑器中，使用<code>&lt;C-f&gt;</code>快捷键，将所有的<code>文章名/</code>替换为空即可删除。</p><p><img src="/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/v2-9202796d27f4659d96ff13b11e6808c1_720w.png" alt="img"></p><p>然后再将博客上传，图片就会随着文章一起打包。在网页中就可以看到正常显示的图片，大功告成。</p><p>————-本地预览不显示图片的问题—————-</p><p>在typora的设置中选择图片工具，为文章设置一个图片根目录。设置方式如下，之后选中存放图片的目录即可，根据不同版本的typora该设置项可以能在不能的位置。</p><p><img src="/2023/06/24/hexo-githubpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/v2-8d28ac51aedad913907c45b4907d325f_720w.webp" alt="img"></p><p>格式 -&gt; 图片工具 -&gt; 设置图片根目录</p><h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p>1.<a href="https://zhuanlan.zhihu.com/p/370635512">超详细 Hexo + Github Pages 博客搭建教程 - 知乎 (zhihu.com)</a></p><p>2.<a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册 (fluid-dev.com)</a></p><p>3.<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid: :ocean: 一款 Material Design 风格的 Hexo 主题 &#x2F; An elegant Material-Design theme for Hexo (github.com)</a></p><p>4.<a href="https://hexo.io/zh-cn/index.html">Hexo</a></p><p>5.<a href="https://github.com/fluid-dev/hexo-theme-fluid/issues/961">Error: Cannot find module ‘css’ · Issue #961 · fluid-dev&#x2F;hexo-theme-fluid (github.com)</a></p><p>6.<a href="https://zhuanlan.zhihu.com/p/265077468">hexo博客如何插入图片 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
